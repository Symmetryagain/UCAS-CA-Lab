From e2eb8d6a2fbe993a086d4dfc4cc97c136871adcb Mon Sep 17 00:00:00 2001
From: symmetree <symmetree@163.com>
Date: Tue, 14 Oct 2025 13:31:55 +0800
Subject: [PATCH] exp6 to exp9

---
 EX.v           |  63 ++++++++
 ID.v           | 298 ++++++++++++++++++++++++++++++++++++
 IF.v           |  95 ++++++++++++
 MEM.v          |  91 +++++++++++
 WB.v           |  30 ++++
 alu.v          |  10 +-
 decoder_2_4.v  |   2 +-
 decoder_4_16.v |   2 +-
 decoder_5_32.v |   2 +-
 decoder_6_64.v |   2 +-
 mycpu_top.v    | 399 +++++++++++++++++++------------------------------
 regfile.v      |   4 +-
 12 files changed, 744 insertions(+), 254 deletions(-)
 create mode 100644 EX.v
 create mode 100644 ID.v
 create mode 100644 IF.v
 create mode 100644 MEM.v
 create mode 100644 WB.v

diff --git a/EX.v b/EX.v
new file mode 100644
index 0000000..e4ee9f2
--- /dev/null
+++ b/EX.v
@@ -0,0 +1,63 @@
+module EX(
+        input   wire            clk,
+        input   wire            rst,
+        input   wire            MEM_allowin,
+        input   wire [181:0]    ID_to_EX_zip,
+        output  wire            front_valid,
+        output  wire [  4:0]    front_addr,
+        output  wire [ 31:0]    front_data,
+        output  wire            EX_allowin,
+        output  reg  [137:0]    EX_to_MEM_reg
+);
+
+wire            valid;
+wire [31:0]     pc;
+wire [31:0]     IR;
+wire [31:0]     src1;
+wire [31:0]     src2;
+wire [11:0]     aluop;
+wire [40:0]     EX_to_MEM_zip;
+
+wire            inst_ld_w;
+wire            mem_we;
+wire            res_from_mem;
+wire            gr_we;
+wire [31:0]     rkd_value;
+wire [ 4:0]     rf_waddr;
+
+assign front_valid = ~inst_ld_w & gr_we;
+assign front_addr = rf_waddr;
+assign front_data = alu_result;
+
+assign EX_allowin = ~valid | MEM_allowin;
+
+assign  {
+        valid, pc, IR, src1, src2, aluop, EX_to_MEM_zip
+} = ID_to_EX_zip;
+
+assign {
+        inst_ld_w, mem_we, res_from_mem, gr_we, rkd_value, rf_waddr
+} = EX_to_MEM_zip;
+
+wire [31:0]     alu_result;
+
+alu u_alu(
+    .alu_op     (aluop),
+    .alu_src1   (src1),
+    .alu_src2   (src2),
+    .alu_result (alu_result)
+);
+
+always @(posedge clk) begin
+        if (rst) begin
+                EX_to_MEM_reg <= 138'b0;
+        end
+        else if (MEM_allowin) begin
+                EX_to_MEM_reg <= {valid & ~rst, pc, IR, EX_to_MEM_zip, alu_result};
+        end
+        else begin
+                EX_to_MEM_reg <= EX_to_MEM_reg;
+        end
+end
+
+endmodule
diff --git a/ID.v b/ID.v
new file mode 100644
index 0000000..89353a2
--- /dev/null
+++ b/ID.v
@@ -0,0 +1,298 @@
+module ID(
+        input   wire            clk,
+        input   wire            rst,
+        input   wire            EX_allowin,
+        input   wire [ 64:0]    IF_to_ID_zip,
+
+        input   wire            last_MEM_done,
+        input   wire [ 31:0]    done_pc,
+        input   wire [ 31:0]    last_load_data,
+
+        input   wire            front_from_EX_valid,
+        input   wire [  4:0]    front_from_EX_addr,
+        input   wire [ 31:0]    front_from_EX_data,
+        input   wire            front_from_MEM_valid,
+        input   wire [  4:0]    front_from_MEM_addr,
+        input   wire [ 31:0]    front_from_MEM_data,
+
+        input   wire [ 31:0]    rf_rdata1,
+        input   wire [ 31:0]    rf_rdata2,
+
+        output  wire            ID_allowin,
+        output  wire [  4:0]    rf_raddr1,
+        output  wire [  4:0]    rf_raddr2,
+        output  wire            flush,
+        output  wire [ 31:0]    pc_real,
+        output  reg  [181:0]    ID_to_EX_reg
+);
+
+reg  [31:0]     last_pc;
+always @(posedge clk) begin
+        if (rst) begin
+                last_pc <= 32'b0;
+        end
+        else if (EX_allowin & readygo) begin
+                last_pc <= pc;
+        end
+        else begin
+                last_pc <= last_pc;
+        end
+end
+
+reg             last_is_load;
+reg  [ 4:0]     last_dest;
+
+reg             valid;
+always @(posedge clk) begin
+        if (rst) begin
+                valid <= 1'b0;
+        end
+        else if (ID_allowin) begin
+                valid <= ~flush;
+        end
+        else begin
+                valid <= valid;
+        end
+end
+
+assign ID_allowin = ~valid | readygo & EX_allowin;
+
+wire            readygo;
+wire            need_pause;
+assign need_pause = (last_dest == rf_raddr1 || last_dest == rf_raddr2) & last_is_load & (last_dest != 0);
+assign readygo = ~need_pause | need_pause & last_MEM_done & (done_pc == last_pc);
+
+wire            predict;
+wire [31:0]     pc;
+wire [31:0]     inst;
+assign {
+        predict, inst, pc
+} = IF_to_ID_zip;
+
+wire [11:0]     alu_op;
+wire            load_op;
+wire            src1_is_pc;
+wire            src2_is_imm;
+wire            res_from_mem;
+wire            dst_is_r1;
+wire            gr_we;
+wire            mem_we;
+wire            src_reg_is_rd;
+wire [ 4:0]     dest;
+wire [31:0]     rj_value;
+wire [31:0]     rkd_value;
+wire            rj_eq_rd;
+wire [31:0]     imm;
+wire [31:0]     br_offs;
+wire [31:0]     jirl_offs;
+wire            br_taken;
+wire [31:0]     br_target;
+
+wire [ 5:0]     op_31_26;
+wire [ 3:0]     op_25_22;
+wire [ 1:0]     op_21_20;
+wire [ 4:0]     op_19_15;
+wire [ 4:0]     rd;
+wire [ 4:0]     rj;
+wire [ 4:0]     rk;
+wire [11:0]     i12;
+wire [19:0]     i20;
+wire [15:0]     i16;
+wire [25:0]     i26;
+
+wire [63:0]     op_31_26_d;
+wire [15:0]     op_25_22_d;
+wire [ 3:0]     op_21_20_d;
+wire [31:0]     op_19_15_d;
+
+wire            inst_add_w;
+wire            inst_sub_w;
+wire            inst_slt;
+wire            inst_sltu;
+wire            inst_nor;
+wire            inst_and;
+wire            inst_or;
+wire            inst_xor;
+wire            inst_slli_w;
+wire            inst_srli_w;
+wire            inst_srai_w;
+wire            inst_addi_w;
+wire            inst_ld_w;
+wire            inst_st_w;
+wire            inst_jirl;
+wire            inst_b;
+wire            inst_bl;
+wire            inst_beq;
+wire            inst_bne;
+wire            inst_lu12i_w;
+
+wire            need_ui5;
+wire            need_si12;
+wire            need_si16;
+wire            need_si20;
+wire            need_si26;
+wire            src2_is_4;
+
+
+assign op_31_26 = inst[31:26];
+assign op_25_22 = inst[25:22];
+assign op_21_20 = inst[21:20];
+assign op_19_15 = inst[19:15];
+
+assign rd       = inst[ 4: 0];
+assign rj       = inst[ 9: 5];
+assign rk       = inst[14:10];
+
+assign i12      = inst[21:10];
+assign i20      = inst[24: 5];
+assign i16      = inst[25:10];
+assign i26      = {inst[ 9: 0], inst[25:10]};
+
+decoder_6_64 u_dec0(.in(op_31_26 ), .out(op_31_26_d ));
+decoder_4_16 u_dec1(.in(op_25_22 ), .out(op_25_22_d ));
+decoder_2_4  u_dec2(.in(op_21_20 ), .out(op_21_20_d ));
+decoder_5_32 u_dec3(.in(op_19_15 ), .out(op_19_15_d ));
+
+assign  inst_add_w      = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h00];
+assign  inst_sub_w      = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h02];
+assign  inst_slt        = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h04];
+assign  inst_sltu       = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h05];
+assign  inst_nor        = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h08];
+assign  inst_and        = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h09];
+assign  inst_or         = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h0a];
+assign  inst_xor        = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h0b];
+assign  inst_slli_w     = op_31_26_d[6'h00] & op_25_22_d[4'h1] & op_21_20_d[2'h0] & op_19_15_d[5'h01];
+assign  inst_srli_w     = op_31_26_d[6'h00] & op_25_22_d[4'h1] & op_21_20_d[2'h0] & op_19_15_d[5'h09];
+assign  inst_srai_w     = op_31_26_d[6'h00] & op_25_22_d[4'h1] & op_21_20_d[2'h0] & op_19_15_d[5'h11];
+assign  inst_addi_w     = op_31_26_d[6'h00] & op_25_22_d[4'ha];
+assign  inst_ld_w       = op_31_26_d[6'h0a] & op_25_22_d[4'h2];
+assign  inst_st_w       = op_31_26_d[6'h0a] & op_25_22_d[4'h6];
+assign  inst_jirl       = op_31_26_d[6'h13];
+assign  inst_b          = op_31_26_d[6'h14];
+assign  inst_bl         = op_31_26_d[6'h15];
+assign  inst_beq        = op_31_26_d[6'h16];
+assign  inst_bne        = op_31_26_d[6'h17];
+assign  inst_lu12i_w    = op_31_26_d[6'h05] & ~inst[25];
+
+assign  alu_op[ 0]      = inst_add_w | inst_addi_w | inst_ld_w | inst_st_w
+                         | inst_jirl | inst_bl;
+assign  alu_op[ 1]      = inst_sub_w;
+assign  alu_op[ 2]      = inst_slt;
+assign  alu_op[ 3]      = inst_sltu;
+assign  alu_op[ 4]      = inst_and;
+assign  alu_op[ 5]      = inst_nor;
+assign  alu_op[ 6]      = inst_or;
+assign  alu_op[ 7]      = inst_xor;
+assign  alu_op[ 8]      = inst_slli_w;
+assign  alu_op[ 9]      = inst_srli_w;
+assign  alu_op[10]      = inst_srai_w;
+assign  alu_op[11]      = inst_lu12i_w;
+
+assign  need_ui5        =  inst_slli_w | inst_srli_w | inst_srai_w;
+assign  need_si12       =  inst_addi_w | inst_ld_w | inst_st_w;
+assign  need_si16       =  inst_jirl | inst_beq | inst_bne;
+assign  need_si20       =  inst_lu12i_w;
+assign  need_si26       =  inst_b | inst_bl;
+assign  src2_is_4       =  inst_jirl | inst_bl;
+
+assign  imm             = src2_is_4 ? 32'h4                      :
+                          need_si20 ? {i20[19:0], 12'b0}         :
+             /*need_ui5 || need_si12*/{{20{i12[11]}}, i12[11:0]} ;
+
+assign  br_offs         = need_si26 ? {{ 4{i26[25]}}, i26[25:0], 2'b0} :
+                             {{14{i16[15]}}, i16[15:0], 2'b0} ;
+
+assign  jirl_offs       = {{14{i16[15]}}, i16[15:0], 2'b0};
+
+assign  src_reg_is_rd   = inst_beq | inst_bne | inst_st_w;
+
+assign  src1_is_pc      = inst_jirl | inst_bl;
+
+assign  src2_is_imm     = inst_slli_w |
+                          inst_srli_w |
+                          inst_srai_w |
+                          inst_addi_w |
+                          inst_ld_w   |
+                          inst_st_w   |
+                          inst_lu12i_w|
+                          inst_jirl   |
+                          inst_bl     ;
+
+assign  res_from_mem    = inst_ld_w;
+assign  dst_is_r1       = inst_bl;
+assign  gr_we           = ~inst_st_w & ~inst_beq & ~inst_bne & ~inst_b;
+assign  mem_we          = inst_st_w;
+assign  dest            = dst_is_r1 ? 5'd1 : rd;
+
+assign  rf_raddr1       = rj;
+assign  rf_raddr2       = src_reg_is_rd ? rd : rk;
+
+assign  rj_value        = need_pause & (last_dest == rf_raddr1) ? last_load_data : 
+                          front_from_EX_valid & (front_from_EX_addr == rf_raddr1) ? front_from_EX_data :
+                          front_from_MEM_valid & (front_from_MEM_addr == rf_raddr1) ? front_from_MEM_data :
+                          rf_rdata1;
+assign  rkd_value       = need_pause & (last_dest == rf_raddr2) ? last_load_data : 
+                          front_from_EX_valid & (front_from_EX_addr == rf_raddr2) ? front_from_EX_data :
+                          front_from_MEM_valid & (front_from_MEM_addr == rf_raddr2) ? front_from_MEM_data :  
+                          rf_rdata2;
+
+assign  rj_eq_rd        = (rj_value == rkd_value);
+assign  br_taken        = (   inst_beq  &&  rj_eq_rd
+                           || inst_bne  && !rj_eq_rd
+                           || inst_jirl
+                           || inst_bl
+                           || inst_b
+                          ) && valid;
+assign  br_target       = (inst_beq || inst_bne || inst_bl || inst_b) ? (pc + br_offs) :
+                                                   /*inst_jirl*/ (rj_value + jirl_offs);
+
+assign  flush           = ((br_taken ^ predict) | inst_jirl) & ~rst & valid;
+
+always @(posedge clk) begin
+        if (rst) begin
+                ID_to_EX_reg <= 182'b0;
+        end
+        else if (EX_allowin & readygo) begin
+                ID_to_EX_reg <= {
+                        valid & ~rst, 
+                        pc, inst,
+                        src1_is_pc ? pc : rj_value,
+                        src2_is_imm ? imm : rkd_value,
+                        alu_op, inst_ld_w, mem_we, res_from_mem, gr_we, rkd_value, dest
+                        };
+        end
+        else if (EX_allowin & ~readygo) begin
+                ID_to_EX_reg <= 182'b0;
+        end
+        else begin
+                ID_to_EX_reg <= ID_to_EX_reg;
+        end
+end
+
+always @(posedge clk) begin
+        if (rst) begin
+                last_is_load <= 1'b0;
+        end
+        else if (EX_allowin & readygo) begin
+                last_is_load <= inst_ld_w;
+        end
+        else begin
+                last_is_load <= last_is_load;
+        end
+end
+
+always @(posedge clk) begin
+        if (rst) begin
+                last_dest <= 5'b0;
+        end
+        else if (EX_allowin & readygo) begin
+                last_dest <= dest;
+        end
+        else begin
+                last_dest <= last_dest;
+        end
+end
+
+assign pc_real = {32{flush}} & br_target;
+
+endmodule
diff --git a/IF.v b/IF.v
new file mode 100644
index 0000000..c29e94e
--- /dev/null
+++ b/IF.v
@@ -0,0 +1,95 @@
+module IF (
+        input   wire            clk,
+        input   wire            rst,
+        input   wire            flush,
+        input   wire            inst_ready,
+        input   wire            inst_valid,
+
+        input   wire            ID_allowin,
+
+        input   wire [31:0]     inst,
+        input   wire [31:0]     pc_real,
+        output  wire            inst_sram_en,
+        output  wire [31:0]     pc_next,
+        output  reg  [64:0]     IF_to_ID_reg
+);
+
+`define PC_INIT 32'h1bfffffc
+
+assign inst_sram_en = ~rst & ID_allowin;
+
+wire            predict;
+// wire            br_taken;
+// wire [31:0]     br_target;
+// wire [ 5:0]     op_31_26;
+// wire            inst_b;
+// wire            inst_bl;
+// wire            inst_beq;
+// wire            inst_bne;
+// wire            inst_jirl;
+// wire            need_si26;
+// wire [31:0]     br_offs;
+// wire [63:0]     op_31_26_d;
+// wire [15:0]     i16;
+// wire [25:0]     i26;
+
+// assign op_31_26         = inst[31:26];
+// assign inst_jirl        = op_31_26_d[6'h13];
+// assign inst_b           = op_31_26_d[6'h14];
+// assign inst_bl          = op_31_26_d[6'h15];
+// assign inst_beq         = op_31_26_d[6'h16];
+// assign inst_bne         = op_31_26_d[6'h17];
+
+// assign need_si26        = inst_b | inst_bl;
+// assign i16              = inst[25:10];
+// assign i26              = {inst[ 9: 0], inst[25:10]};
+// assign br_offs          = need_si26 ? {{ 4{i26[25]}}, i26[25:0], 2'b0}:
+//                                       {{14{i16[15]}}, i16[15:0], 2'b0};
+
+assign predict          = 1'b0;
+// assign br_taken         = inst_beq & predict | inst_bne & predict | inst_bl | inst_b | inst_jirl;
+// assign br_target        = pc_reg + br_offs;
+
+// decoder_6_64 u_dec0(.in(op_31_26), .out(op_31_26_d));
+
+reg  [31:0]     pc;
+reg  [31:0]     IR;
+
+assign pc_next = flush ? pc_real : pc + 4;
+
+always @(posedge clk) begin
+        if (rst) begin
+                pc <= `PC_INIT;
+        end
+        else if (ID_allowin) begin 
+                pc <= pc_next;
+        end 
+        else begin
+                pc <= pc;
+        end
+end
+
+always @(posedge clk) begin
+        if (rst) begin
+                IR <= 32'b0;
+        end
+        else if (ID_allowin) begin
+                IR <= inst;
+        end
+        else begin
+                IR <= IR;
+        end
+end
+
+always @(posedge clk) begin
+        if (rst) begin
+                IF_to_ID_reg <= {1'b0, 32'b0, `PC_INIT};
+        end
+        else if (ID_allowin) begin
+                IF_to_ID_reg <= {predict, inst, pc};
+        end else begin
+                IF_to_ID_reg <= IF_to_ID_reg;
+        end
+end
+
+endmodule
diff --git a/MEM.v b/MEM.v
new file mode 100644
index 0000000..2c055fb
--- /dev/null
+++ b/MEM.v
@@ -0,0 +1,91 @@
+module MEM(
+        input   wire            clk,
+        input   wire            rst,
+        input   wire            WB_allowin,
+        
+        input   wire            data_ready,
+        input   wire            data_valid,
+        input   wire [ 31:0]    read_data,
+        input   wire [137:0]    EX_to_MEM_zip,
+
+        output  wire            front_valid,
+        output  wire [  4:0]    front_addr,
+        output  wire [ 31:0]    front_data,
+        output  wire            MEM_done,
+        output  wire [ 31:0]    done_pc,
+        output  wire [ 31:0]    loaded_data,
+
+        output  wire            MEM_allowin,
+        output  wire            write_en,
+        output  wire [  3:0]    write_we,
+        output  wire [ 31:0]    write_addr,
+        output  wire [ 31:0]    write_data,
+        output  reg  [102:0]    MEM_to_WB_reg
+);
+
+wire            valid;
+wire [31:0]     pc;
+wire [31:0]     IR;
+wire            inst_ld_w;
+wire            mem_we;
+wire            res_from_mem;
+wire            gr_we;
+wire [31:0]     rkd_value;
+wire [31:0]     alu_result;
+wire [ 4:0]     rf_waddr;
+wire [31:0]     rf_wdata;
+
+assign done_pc = pc;
+assign front_valid = ~inst_ld_w & gr_we;
+assign front_addr = rf_waddr;
+assign front_data = alu_result;
+assign MEM_done = readygo;
+assign loaded_data = read_data;
+
+reg             readygo;
+
+always @(posedge clk) begin
+        if (rst) begin
+                readygo <= 1'b0;
+        end
+        else if (~readygo & (data_ready | data_valid)) begin
+                readygo <= 1'b1;
+        end
+        else if (readygo & WB_allowin) begin
+                readygo <= 1'b0;
+        end
+        else begin
+                readygo <= readygo;
+        end
+end
+
+assign MEM_allowin = ~valid | (readygo & WB_allowin);
+
+assign  {
+        valid, pc, IR, inst_ld_w, mem_we, res_from_mem, gr_we, rkd_value, rf_waddr, alu_result
+} = EX_to_MEM_zip;
+
+
+assign rf_wdata = res_from_mem ? read_data : alu_result;
+
+assign write_en = (mem_we | inst_ld_w) & valid;
+assign write_we = {4{mem_we & valid}};
+assign write_addr = alu_result;
+assign write_data = rkd_value;
+
+always @(posedge clk) begin
+        if (rst) begin
+                MEM_to_WB_reg <= 103'b0;
+        end
+        else if (readygo & WB_allowin) begin
+                MEM_to_WB_reg <= {valid & ~rst, pc, IR, gr_we, rf_waddr, rf_wdata};
+        end
+        else if (~readygo & WB_allowin) begin
+                MEM_to_WB_reg <= 103'b0;
+        end 
+        else begin
+                MEM_to_WB_reg <= MEM_to_WB_reg;
+        end
+end
+
+endmodule
diff --git a/WB.v b/WB.v
new file mode 100644
index 0000000..b2fda1a
--- /dev/null
+++ b/WB.v
@@ -0,0 +1,30 @@
+module WB(
+        input   wire            clk,
+        input   wire            rst,
+        input   wire [102:0]    MEM_to_WB_zip,
+        
+        output  wire            WB_allowin,
+        output  wire            rf_wen,
+        output  wire [  4:0]    rf_waddr,
+        output  wire [ 31:0]    rf_wdata,
+        output  reg  [ 72:0]    inst_retire_reg
+);
+
+wire            valid;
+wire [31:0]     pc;
+wire [31:0]     IR;
+wire            gr_we;
+
+assign WB_allowin = 1'b1;
+
+assign {
+    valid, pc, IR, gr_we, rf_waddr, rf_wdata
+} = MEM_to_WB_zip;
+
+assign rf_wen   = gr_we & valid;
+
+always @(posedge clk) begin
+        inst_retire_reg <= {pc, {4{rf_wen}}, rf_waddr, rf_wdata};
+end
+
+endmodule
\ No newline at end of file
diff --git a/alu.v b/alu.v
index d785fe2..d2ce1a8 100644
--- a/alu.v
+++ b/alu.v
@@ -55,7 +55,7 @@ wire        adder_cout;
 assign adder_a   = alu_src1;
 assign adder_b   = (op_sub | op_slt | op_sltu) ? ~alu_src2 : alu_src2;  //src1 - src2 rj-rk
 assign adder_cin = (op_sub | op_slt | op_sltu) ? 1'b1      : 1'b0;
-assign {adder_cout, adder_result} = adder_a + adder_b + adder_cin;
+assign {adder_cout, adder_result} = adder_a + adder_b + {32'b0, adder_cin};
 
 // ADD, SUB result
 assign add_sub_result = adder_result;
@@ -71,18 +71,18 @@ assign sltu_result[0]    = ~adder_cout;
 
 // bitwise operation
 assign and_result = alu_src1 & alu_src2;
-assign or_result  = alu_src1 | alu_src2 | alu_result;
+assign or_result  = alu_src1 | alu_src2;
 assign nor_result = ~or_result;
 assign xor_result = alu_src1 ^ alu_src2;
 assign lui_result = alu_src2;
 
 // SLL result
-assign sll_result = alu_src2 << alu_src1[4:0];   //rj << i5
+assign sll_result = alu_src1 << alu_src2[4:0];   //rj << i5
 
 // SRL, SRA result
-assign sr64_result = {{32{op_sra & alu_src2[31]}}, alu_src2[31:0]} >> alu_src1[4:0]; //rj >> i5
+assign sr64_result = {{32{op_sra & alu_src1[31]}}, alu_src1[31:0]} >> alu_src2[4:0]; //rj >> i5
 
-assign sr_result   = sr64_result[30:0];
+assign sr_result   = sr64_result[31:0];
 
 // final result mux
 assign alu_result = ({32{op_add|op_sub}} & add_sub_result)
diff --git a/decoder_2_4.v b/decoder_2_4.v
index fce53ab..e7c709a 100644
--- a/decoder_2_4.v
+++ b/decoder_2_4.v
@@ -8,4 +8,4 @@ generate for (i=0; i<4; i=i+1) begin : gen_for_dec_2_4
     assign out[i] = (in == i);
 end endgenerate
 
-endmodule
\ No newline at end of file
+endmodule
diff --git a/decoder_4_16.v b/decoder_4_16.v
index 992f20a..089450e 100644
--- a/decoder_4_16.v
+++ b/decoder_4_16.v
@@ -8,4 +8,4 @@ generate for (i=0; i<16; i=i+1) begin : gen_for_dec_4_16
     assign out[i] = (in == i);
 end endgenerate
 
-endmodule
\ No newline at end of file
+endmodule
diff --git a/decoder_5_32.v b/decoder_5_32.v
index aecd3c5..9d552b8 100644
--- a/decoder_5_32.v
+++ b/decoder_5_32.v
@@ -8,4 +8,4 @@ generate for (i=0; i<32; i=i+1) begin : gen_for_dec_5_32
     assign out[i] = (in == i);
 end endgenerate
 
-endmodule
\ No newline at end of file
+endmodule
diff --git a/decoder_6_64.v b/decoder_6_64.v
index c360deb..8bfdfb5 100644
--- a/decoder_6_64.v
+++ b/decoder_6_64.v
@@ -8,4 +8,4 @@ generate for (i=0; i<64; i=i+1) begin : gen_for_dec_6_64
     assign out[i] = (in == i);
 end endgenerate
 
-endmodule
\ No newline at end of file
+endmodule
diff --git a/mycpu_top.v b/mycpu_top.v
index b10d980..6f599fa 100644
--- a/mycpu_top.v
+++ b/mycpu_top.v
@@ -2,12 +2,14 @@ module mycpu_top(
     input  wire        clk,
     input  wire        resetn,
     // inst sram interface
-    output wire        inst_sram_we,
+    output wire        inst_sram_en,
+    output wire [ 3:0] inst_sram_we,
     output wire [31:0] inst_sram_addr,
     output wire [31:0] inst_sram_wdata,
     input  wire [31:0] inst_sram_rdata,
     // data sram interface
-    output wire        data_sram_we,
+    output wire        data_sram_en,
+    output wire [ 3:0] data_sram_we,
     output wire [31:0] data_sram_addr,
     output wire [31:0] data_sram_wdata,
     input  wire [31:0] data_sram_rdata,
@@ -17,259 +19,170 @@ module mycpu_top(
     output wire [ 4:0] debug_wb_rf_wnum,
     output wire [31:0] debug_wb_rf_wdata
 );
-reg         reset;
-always @(posedge clk) reset <= ~resetn;
-
-reg         valid;
-always @(posedge clk) begin
-    if (reset) begin
-        valid <= 1'b0;
-    end
-    else begin
-        valid <= 1'b1;
-    end
-end
-
-wire [31:0] seq_pc;
-wire [31:0] nextpc;
-wire        br_taken;
-wire [31:0] br_target;
-wire [31:0] inst;
-reg  [31:0] pc;
-
-wire [11:0] alu_op;
-wire        load_op;
-wire        src1_is_pc;
-wire        src2_is_imm;
-wire        res_from_mem;
-wire        dst_is_r1;
-wire        gr_we;
-wire        mem_we;
-wire        src_reg_is_rd;
-wire [4: 0] dest;
-wire [31:0] rj_value;
-wire [31:0] rkd_value;
-wire [31:0] imm;
-wire [31:0] br_offs;
-wire [31:0] jirl_offs;
-
-wire [ 5:0] op_31_26;
-wire [ 3:0] op_25_22;
-wire [ 1:0] op_21_20;
-wire [ 4:0] op_19_15;
-wire [ 4:0] rd;
-wire [ 4:0] rj;
-wire [ 4:0] rk;
-wire [11:0] i12;
-wire [19:0] i20;
-wire [15:0] i16;
-wire [25:0] i26;
-
-wire [63:0] op_31_26_d;
-wire [15:0] op_25_22_d;
-wire [ 3:0] op_21_20_d;
-wire [31:0] op_19_15_d;
-
-wire        inst_add_w;
-wire        inst_sub_w;
-wire        inst_slt;
-wire        inst_sltu;
-wire        inst_nor;
-wire        inst_and;
-wire        inst_or;
-wire        inst_xor;
-wire        inst_slli_w;
-wire        inst_srli_w;
-wire        inst_srai_w;
-wire        inst_addi_w;
-wire        inst_ld_w;
-wire        inst_st_w;
-wire        inst_jirl;
-wire        inst_b;
-wire        inst_bl;
-wire        inst_beq;
-wire        inst_bne;
-wire        inst_lu12i_w;
-
-wire        need_ui5;
-wire        need_si12;
-wire        need_si16;
-wire        need_si20;
-wire        need_si26;
-wire        src2_is_4;
-
-wire [ 4:0] rf_raddr1;
-wire [31:0] rf_rdata1;
-wire [ 4:0] rf_raddr2;
-wire [31:0] rf_rdata2;
-wire        rf_we   ;
-wire [ 4:0] rf_waddr;
-wire [31:0] rf_wdata;
-
-wire [31:0] alu_src1   ;
-wire [31:0] alu_src2   ;
-wire [31:0] alu_result ;
-
-wire [31:0] mem_result;
-
-assign seq_pc       = pc + 32'h4;
-assign nextpc       = br_taken ? br_target : seq_pc;
-
-always @(posedge clk) begin
-    if (reset) begin
-        pc <= 32'h1bfffffc;     //trick: to make nextpc be 0x1c000000 during reset 
-    end
-    else begin
-        pc <= nextpc;
-    end
-end
-
-assign inst_sram_we    = 1'b0;
-assign inst_sram_addr  = pc;
-assign inst_sram_wdata = 32'b0;
-assign inst            = inst_sram_rdata;
-
-assign op_31_26  = inst[31:26];
-assign op_25_22  = inst[25:22];
-assign op_21_20  = inst[21:20];
-assign op_19_15  = inst[19:15];
-
-assign rd   = inst[ 4: 0];
-assign rj   = inst[ 9: 5];
-assign rk   = inst[14:10];
-
-assign i12  = inst[21:10];
-assign i20  = inst[24: 5];
-assign i16  = inst[25:10];
-assign i26  = {inst[ 9: 0], inst[25:10]};
-
-decoder_6_64 u_dec0(.in(op_31_26 ), .out(op_31_26_d ));
-decoder_4_16 u_dec1(.in(op_25_22 ), .out(op_25_22_d ));
-decoder_2_4  u_dec2(.in(op_21_20 ), .out(op_21_20_d ));
-decoder_5_32 u_dec3(.in(op_19_15 ), .out(op_19_15_d ));
 
-assign inst_add_w  = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h00];
-assign inst_sub_w  = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h02];
-assign inst_slt    = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h04];
-assign inst_sltu   = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h05];
-assign inst_nor    = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h08];
-assign inst_and    = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h09];
-assign inst_or     = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h0a];
-assign inst_xor    = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h0b];
-assign inst_slli_w = op_31_26_d[6'h00] & op_25_22_d[4'h1] & op_21_20_d[2'h0] & op_19_15_d[5'h01];
-assign inst_srli_w = op_31_26_d[6'h00] & op_25_22_d[4'h1] & op_21_20_d[2'h0] & op_19_15_d[5'h09];
-assign inst_srai_w = op_31_26_d[6'h00] & op_25_22_d[4'h1] & op_21_20_d[2'h0] & op_19_15_d[5'h11];
-assign inst_addi_w = op_31_26_d[6'h00] & op_25_22_d[4'ha];
-assign inst_ld_w   = op_31_26_d[6'h0a] & op_25_22_d[4'h2];
-assign inst_st_w   = op_31_26_d[6'h0a] & op_25_22_d[4'h6];
-assign inst_jirl   = op_31_26_d[6'h13];
-assign inst_b      = op_31_26_d[6'h14];
-assign inst_bl     = op_31_26_d[6'h15];
-assign inst_beq    = op_31_26_d[6'h16];
-assign inst_bne    = op_31_26_d[6'h17];
-assign inst_lu12i_w= op_31_26_d[6'h05] & ~inst[25];
-
-assign alu_op[ 0] = inst_add_w | inst_addi_w | inst_ld_w | inst_st_w
-                    | inst_jirl | inst_bl;
-assign alu_op[ 1] = inst_sub_w;
-assign alu_op[ 2] = inst_slt;
-assign alu_op[ 3] = inst_sltu;
-assign alu_op[ 4] = inst_and;
-assign alu_op[ 5] = inst_nor;
-assign alu_op[ 6] = inst_or;
-assign alu_op[ 7] = inst_xor;
-assign alu_op[ 8] = inst_slli_w;
-assign alu_op[ 9] = inst_srli_w;
-assign alu_op[10] = inst_srai_w;
-assign alu_op[11] = inst_lu12i_w;
-
-assign need_ui5   =  inst_slli_w | inst_srli_w | inst_srai_w;
-assign need_si12  =  inst_addi_w | inst_ld_w | inst_st_w;
-assign need_si16  =  inst_jirl | inst_beq | inst_bne;
-assign need_si20  =  inst_lu12i_w;
-assign need_si26  =  inst_b | inst_bl;
-assign src2_is_4  =  inst_jirl | inst_bl;
-
-assign imm = src2_is_4 ? 32'h4                      :
-             need_si20 ? {i20[19:0], 12'b0}         :
-/*need_ui5 || need_si12*/{{20{i12[11]}}, i12[11:0]} ;
-
-assign br_offs = need_si26 ? {{ 4{i26[25]}}, i26[25:0], 2'b0} :
-                             {{14{i16[15]}}, i16[15:0], 2'b0} ;
+reg             reset;
+always @(posedge clk) reset <= ~resetn;
 
-assign jirl_offs = {{14{i16[15]}}, i16[15:0], 2'b0};
+// allowin
+wire         ID_allowin;
+wire         EX_allowin;
+wire         MEM_allowin;
+wire         WB_allowin;
+
+// memory signal
+wire         inst_ready;
+wire         inst_valid;
+wire         data_ready;
+wire         data_valid;
+
+assign inst_ready = 1'b1;
+assign inst_valid = 1'b1;
+assign data_ready = 1'b1;
+assign data_valid = 1'b1;
+
+// internal pipeline zipes
+wire [64:0]  IF_to_ID_reg;
+wire [181:0] ID_to_EX_reg;
+wire [137:0] EX_to_MEM_reg;
+wire [102:0] MEM_to_WB_reg;
+
+// IF <-> ID signals
+wire         ID_flush;
+wire [31:0]  ID_pc_real;
+
+// regfile <-> ID / WB
+wire [4:0]   rf_raddr1;
+wire [4:0]   rf_raddr2;
+wire [31:0]  rf_rdata1;
+wire [31:0]  rf_rdata2;
+
+wire         wb_rf_wen;
+wire [4:0]   wb_rf_waddr;
+wire [31:0]  wb_rf_wdata;
+
+// WB inst_retire
+wire [72:0]  wb_inst_retire_reg;
+
+wire           EX_front_valid;
+wire [ 4:0]    EX_front_addr;
+wire [31:0]    EX_front_data;
+wire           MEM_front_valid;
+wire [ 4:0]    MEM_front_addr;
+wire [31:0]    MEM_front_data;
+wire           MEM_done;
+wire [31:0]    loaded_data;
+
+wire [31:0]    done_pc;
+
+// IF instance
+IF u_IF (
+    .clk            (clk),
+    .rst            (reset),
+    .flush          (ID_flush),
+    .inst           (inst_sram_rdata),
+    .pc_real        (ID_pc_real),
+    .pc_next        (inst_sram_addr),
+    .IF_to_ID_reg   (IF_to_ID_reg),
+    .ID_allowin     (ID_allowin),
+    .inst_ready     (inst_ready),
+    .inst_valid     (inst_valid),
+    .inst_sram_en   (inst_sram_en)
+);
 
-assign src_reg_is_rd = inst_beq | inst_bne | inst_st_w;
+// ID instance
+ID u_ID (
+    .clk            (clk),
+    .rst            (reset),
+    .IF_to_ID_zip   (IF_to_ID_reg),
+    .front_from_EX_valid (EX_front_valid),
+    .front_from_EX_addr  (EX_front_addr),
+    .front_from_EX_data  (EX_front_data),
+    .front_from_MEM_valid(MEM_front_valid),
+    .front_from_MEM_addr (MEM_front_addr),
+    .front_from_MEM_data (MEM_front_data),
+    .last_MEM_done  (MEM_done),
+    .last_load_data (loaded_data),
+    .rf_rdata1      (rf_rdata1),
+    .rf_rdata2      (rf_rdata2),
+    .rf_raddr1      (rf_raddr1),
+    .rf_raddr2      (rf_raddr2),
+    .flush          (ID_flush),
+    .pc_real        (ID_pc_real),
+    .ID_to_EX_reg   (ID_to_EX_reg),
+    .ID_allowin     (ID_allowin),
+    .EX_allowin     (EX_allowin),
+    .done_pc        (done_pc)
+);
 
-assign src1_is_pc    = inst_jirl | inst_bl;
+// EX instance
+EX u_EX (
+    .clk            (clk),
+    .rst            (reset),
+    .ID_to_EX_zip   (ID_to_EX_reg),
+    .EX_to_MEM_reg  (EX_to_MEM_reg),
+    .EX_allowin     (EX_allowin),
+    .MEM_allowin    (MEM_allowin),
+    .front_valid    (EX_front_valid),
+    .front_addr     (EX_front_addr),
+    .front_data     (EX_front_data)
+);
 
-assign src2_is_imm   = inst_slli_w |
-                       inst_srli_w |
-                       inst_srai_w |
-                       inst_addi_w |
-                       inst_ld_w   |
-                       inst_st_w   |
-                       inst_lu12i_w|
-                       inst_jirl   |
-                       inst_bl     ;
+// MEM instance (connect its memory read_data to data_sram_rdata, and drive data_sram_* outputs)
+MEM u_MEM (
+    .clk            (clk),
+    .rst            (reset),
+    .EX_to_MEM_zip  (EX_to_MEM_reg),
+    .write_en       (data_sram_en),
+    .write_we       (data_sram_we),
+    .write_addr     (data_sram_addr),
+    .write_data     (data_sram_wdata),
+    .MEM_to_WB_reg  (MEM_to_WB_reg),
+    .read_data      (data_sram_rdata),
+    .MEM_allowin    (MEM_allowin),
+    .WB_allowin     (WB_allowin),
+    .data_ready     (data_ready),
+    .data_valid     (data_valid),
+    .front_valid    (MEM_front_valid),
+    .front_addr     (MEM_front_addr),
+    .front_data     (MEM_front_data),
+    .MEM_done       (MEM_done),
+    .loaded_data    (loaded_data),
+    .done_pc        (done_pc)
+);
 
-assign res_from_mem  = inst_ld_w;
-assign dst_is_r1     = inst_bl;
-assign gr_we         = ~inst_st_w & ~inst_beq & ~inst_bne & ~inst_b & ~inst_bl;
-assign mem_we        = inst_st_w;
-assign dest          = dst_is_r1 ? 5'd1 : rd;
+// WB instance
+WB u_WB (
+    .clk            (clk),
+    .rst            (reset),
+    .MEM_to_WB_zip  (MEM_to_WB_reg),
+    .rf_wen         (wb_rf_wen),
+    .rf_waddr       (wb_rf_waddr),
+    .rf_wdata       (wb_rf_wdata),
+    .inst_retire_reg(wb_inst_retire_reg),
+    .WB_allowin     (WB_allowin)
+);
 
-assign rf_raddr1 = rj;
-assign rf_raddr2 = src_reg_is_rd ? rd :rk;
-regfile u_regfile(
-    .clk    (clk      ),
+// regfile instance
+regfile u_regfile (
+    .clk    (clk),
     .raddr1 (rf_raddr1),
     .rdata1 (rf_rdata1),
     .raddr2 (rf_raddr2),
     .rdata2 (rf_rdata2),
-    .we     (rf_we    ),
-    .waddr  (rf_waddr ),
-    .wdata  (rf_wdata )
-    );
-
-assign rj_value  = rf_rdata1;
-assign rkd_value = rf_rdata2;
-
-assign rj_eq_rd = (rj_value == rkd_value);
-assign br_taken = (   inst_beq  &&  rj_eq_rd
-                   || inst_bne  && !rj_eq_rd
-                   || inst_jirl
-                   || inst_bl
-                   || inst_b
-                  ) && valid;
-assign br_target = (inst_beq || inst_bne || inst_bl || inst_b) ? (pc + br_offs) :
-                                                   /*inst_jirl*/ (rj_value + jirl_offs);
-
-assign alu_src1 = src1_is_pc  ? pc[31:0] : rj_value;
-assign alu_src2 = src2_is_imm ? imm : rkd_value;
-
-alu u_alu(
-    .alu_op     (alu_op    ),
-    .alu_src1   (alu_src2  ),
-    .alu_src2   (alu_src2  ),
-    .alu_result (alu_result)
-    );
-
-assign data_sram_we    = mem_we && valid;
-assign data_sram_addr  = alu_result;
-assign data_sram_wdata = rkd_value;
-
-assign mem_result   = data_sram_rdata;
-assign final_result = res_from_mem ? mem_result : alu_result;
+    .we     (wb_rf_wen),
+    .waddr  (wb_rf_waddr),
+    .wdata  (wb_rf_wdata)
+);
 
-assign rf_we    = gr_we && valid;
-assign rf_waddr = dest;
-assign rf_wdata = final_result;
+// tie-off instruction sram write controls (read-only from CPU)
+assign inst_sram_we    = 4'b0;
+assign inst_sram_wdata = 32'b0;
 
-// debug info generate
-assign debug_wb_pc       = pc;
-assign debug_wb_rf_wen   = {4{rf_we}};
-assign debug_wb_rf_wnum  = dest;
-assign debug_wb_rf_wdata = final_result;
+// debug outputs from WB.inst_retire_reg
+// inst_retire_reg format: { pc(32), {4{rf_wen}}(4), rf_waddr(5), rf_wdata(32) }
+assign debug_wb_pc         = wb_inst_retire_reg[72:41];
+assign debug_wb_rf_we      = wb_inst_retire_reg[40:37];
+assign debug_wb_rf_wnum    = wb_inst_retire_reg[36:32];
+assign debug_wb_rf_wdata   = wb_inst_retire_reg[31:0];
 
 endmodule
diff --git a/regfile.v b/regfile.v
index 3f83aac..4863d39 100644
--- a/regfile.v
+++ b/regfile.v
@@ -19,9 +19,9 @@ always @(posedge clk) begin
 end
 
 //READ OUT 1
-assign rdata1 = (raddr1==5'b0) ? 32'b0 : rf[raddr1];
+assign rdata1 = (raddr1==5'b0) ? 32'b0 : (we && raddr1 == waddr) ? wdata : rf[raddr1];
 
 //READ OUT 2
-assign rdata2 = (raddr2==5'b0) ? 32'b0 : rf[raddr2];
+assign rdata2 = (raddr2==5'b0) ? 32'b0 : (we && raddr2 == waddr) ? wdata : rf[raddr2];
 
 endmodule
-- 
2.48.1

