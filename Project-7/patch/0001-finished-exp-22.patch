From a829d66c7364e3c8d4d431bf41db61b843299a25 Mon Sep 17 00:00:00 2001
From: symmetree <symmetree@163.com>
Date: Tue, 6 Jan 2026 17:59:39 +0800
Subject: [PATCH] finished exp 22

---
 EX.v        |   35 +-
 IF.v        |   74 ++-
 MEM.v       |   42 +-
 bridge.v    |  489 +++++++++++--------
 cache.v     |  465 ++++++++++++++++++
 mmu.v       |   66 +--
 mycpu_top.v | 1308 ++++++++++++++++++++++++++++-----------------------
 7 files changed, 1594 insertions(+), 885 deletions(-)
 create mode 100644 cache.v

diff --git a/EX.v b/EX.v
index 7fc7da3..309501d 100644
--- a/EX.v
+++ b/EX.v
@@ -19,7 +19,7 @@ module EX #(
         input   wire [  8:0]    ID_except_zip,
         // EX -> MEM
         output  wire            EX_to_MEM,
-        output  wire [262:0]    EX_to_MEM_zip,
+        output  wire [263:0]    EX_to_MEM_zip,
         output  wire [ 14:0]    EX_except_zip,
         // MEM -> EX
         input   wire            MEM_allowin,
@@ -30,10 +30,11 @@ module EX #(
         output  wire            invtlb_valid,
         output  wire [  4:0]    invtlb_op,
         output  wire [  9:0]    s1_asid,
-        output  wire [ 31:0]    vaddr,
+        output  reg  [ 31:0]    vaddr,
         // top -> EX
         /// mmu
         input   wire [ 31:0]    addr_trans,
+        input   wire            addr_cacheable,
         input   wire            except_tlbr,
         input   wire            except_pil,
         input   wire            except_pis,
@@ -173,12 +174,23 @@ wire [31:0]     compute_result;
 wire [32:0]     mul_src1;
 wire [32:0]     mul_src2;
 wire [65:0]     prod;
+reg  [65:0]     prod_reg;
 
 assign          mul_src1        = {~inst_mulhu & src1[31], src1};
 assign          mul_src2        = {~inst_mulhu & src2[31], src2};
 assign          prod            = $signed(mul_src1) * $signed(mul_src2);
-assign          compute_result  = inst_mul?                     prod[31:0]:
-                                  (inst_mulh | inst_mulhu)?     prod[63:32]:
+
+always @(posedge clk) begin
+        if(rst) begin
+                prod_reg <= 66'b0;
+        end
+        else begin
+                prod_reg <= prod;
+        end
+end
+
+assign          compute_result  = inst_mul?                     prod_reg[31:0]:
+                                  (inst_mulh | inst_mulhu)?     prod_reg[63:32]:
                                   inst_div?                     div_result[63:32]:
                                   inst_mod?                     div_result[31:0]:
                                   inst_divu?                    udiv_result[63:32]:
@@ -228,9 +240,20 @@ assign invtlb_valid = valid & inst_invtlb;
 assign invtlb_op = rf_waddr;
 assign s1_asid = inst_invtlb?   src1           [`CSR_ASID_ASID  ] : 
                                 csr_asid_data  [`CSR_ASID_ASID  ] ;
-assign vaddr   = inst_invtlb?  {rkd_value      [`CSR_TLBEHI_VPPN] , 13'b0} : 
+
+wire [31:0]     address;
+assign address = inst_invtlb?  {rkd_value      [`CSR_TLBEHI_VPPN] , 13'b0} : 
                  inst_tlbsrch? {csr_tlbehi_data[`CSR_TLBEHI_VPPN] , 13'b0} :
                                 alu_result                                 ;
+always @(posedge clk) begin
+        if(rst) begin
+                vaddr <= 32'b0;
+        end
+        else begin
+                vaddr <= address;
+        end
+end
+
 
 reg             init;
 reg             wait_src_ready;
@@ -333,7 +356,7 @@ assign EX_to_MEM_zip = {
         inst_ld_b, inst_ld_bu, inst_ld_h, inst_ld_hu, inst_ld_w, 
         inst_st_b, inst_st_h, inst_st_w,
         mem_we, res_from_mem, gr_we, rkd_value, rf_waddr,
-        compute_result, is_csr, addr_trans,
+        compute_result, is_csr, addr_trans, addr_cacheable,
         inst_tlbsrch, inst_tlbrd, inst_tlbwr, inst_tlbfill, inst_invtlb,
         csr_re, csr_we, 
         csr_wmask | {16'b0, {16{inst_tlbsrch & s1_found}}}, 
diff --git a/IF.v b/IF.v
index db127c0..33a96aa 100644
--- a/IF.v
+++ b/IF.v
@@ -5,18 +5,20 @@ module IF (
         input   wire            rst,
         // IF -> top
         output  wire [31:0]     pc_next,
-        output  wire            inst_sram_en,
+        output  wire            inst_req,
         output  reg  [31:0]     pc_paddr,
+        output  reg             cacheable,
         // top -> IF
-        /// inst_sram
-        input   wire            inst_sram_addr_ok,
-        input   wire            inst_sram_data_ok,
+        /// I-Cache
+        input   wire            icache_addr_ok,
+        input   wire            icache_data_ok,
         input   wire [31:0]     inst,
         /// flush
         input   wire            flush,
         input   wire [31:0]     flush_target,
         /// mmu
         input   wire [31:0]     pc_trans,
+        input   wire            pc_cacheable,
         input   wire            except_tlbr,
         input   wire            except_pif,
         input   wire            except_ppi,
@@ -39,19 +41,6 @@ wire            except_adef;
 wire            g_flush;
 wire            nxt_is_wait_addr_ok;
 wire            predict;
-// wire            br_taken;
-// wire [31:0]     br_target;
-// wire [ 5:0]     op_31_26;
-// wire            inst_b;
-// wire            inst_bl;
-// wire            inst_beq;
-// wire            inst_bne;
-// wire            inst_jirl;
-// wire            need_si26;
-// wire [31:0]     br_offs;
-// wire [63:0]     op_31_26_d;
-// wire [15:0]     i16;
-// wire [25:0]     i26;
 
 reg  [31:0]     pc;
 reg  [31:0]     IR;
@@ -65,32 +54,17 @@ reg  [31:0]     last_target;
 assign IF_to_ID         = readygo & ID_allowin;
 assign IF_to_ID_zip     = {valid & ~g_flush, pc, IR, predict};
 assign IF_except_zip    = {except_adef, except_tlbr, except_pif, except_ppi};
-assign inst_sram_en     = wait_addr_ok | lock_addr;
+assign inst_req         = wait_addr_ok | lock_addr;
 assign pc_next          = flush ? flush_target : 
                                 ID_flush ? ID_flush_target : 
                                 lock_data ? last_target : pc + 4;
 assign except_adef      = (|pc[1:0]);
 assign g_flush          = flush | ID_flush;
 assign predict          = 1'b0;
-assign nxt_is_wait_addr_ok      = wait_data_ok & g_flush & inst_sram_data_ok
+assign nxt_is_wait_addr_ok      = wait_data_ok & g_flush & icache_data_ok
                                 | readygo & g_flush 
                                 | readygo & ID_allowin 
-                                | lock_data & inst_sram_data_ok;
-// assign op_31_26         = inst[31:26];
-// assign inst_jirl        = op_31_26_d[6'h13];
-// assign inst_b           = op_31_26_d[6'h14];
-// assign inst_bl          = op_31_26_d[6'h15];
-// assign inst_beq         = op_31_26_d[6'h16];
-// assign inst_bne         = op_31_26_d[6'h17];
-// assign need_si26        = inst_b | inst_bl;
-// assign i16              = inst[25:10];
-// assign i26              = {inst[ 9: 0], inst[25:10]};
-// assign br_offs          = need_si26 ? {{ 4{i26[25]}}, i26[25:0], 2'b0}:
-//                                       {{14{i16[15]}}, i16[15:0], 2'b0};
-// assign br_taken         = inst_beq & predict | inst_bne & predict | inst_bl | inst_b | inst_jirl;
-// assign br_target        = pc_reg + br_offs;
-
-// decoder_6_64 u_dec0(.in(op_31_26), .out(op_31_26_d));
+                                | lock_data & icache_data_ok;
 
 always @(posedge clk) begin
         if (rst) begin
@@ -123,7 +97,7 @@ always @(posedge clk) begin
         else if (nxt_is_wait_addr_ok) begin
                 wait_addr_ok <= 1'b1;
         end
-        else if (wait_addr_ok & inst_sram_addr_ok | wait_addr_ok & g_flush) begin
+        else if (wait_addr_ok & icache_addr_ok | wait_addr_ok & g_flush) begin
                 wait_addr_ok <= 1'b0;
         end
         else begin
@@ -135,10 +109,10 @@ always @(posedge clk) begin
         if (rst | g_flush) begin
                 wait_data_ok <= 1'b0;
         end
-        else if (wait_addr_ok & inst_sram_addr_ok) begin
+        else if (wait_addr_ok & icache_addr_ok) begin
                 wait_data_ok <= 1'b1;
         end
-        else if (wait_data_ok & inst_sram_data_ok) begin
+        else if (wait_data_ok & icache_data_ok) begin
                 wait_data_ok <= 1'b0;
         end
         else begin
@@ -153,7 +127,7 @@ always @(posedge clk) begin
         else if (g_flush) begin
                 readygo <= 1'b0;
         end
-        else if (wait_data_ok & inst_sram_data_ok) begin
+        else if (wait_data_ok & icache_data_ok) begin
                 readygo <= 1'b1;
         end
         else if (readygo & ID_allowin) begin
@@ -168,10 +142,10 @@ always @(posedge clk) begin
         if (rst) begin
                 lock_addr <= 1'b0;
         end
-        else if (wait_addr_ok & g_flush & ~inst_sram_addr_ok) begin
+        else if (wait_addr_ok & g_flush & ~icache_addr_ok) begin
                 lock_addr <= 1'b1;
         end
-        else if (lock_addr & inst_sram_addr_ok) begin 
+        else if (lock_addr & icache_addr_ok) begin 
                 lock_addr <= 1'b0;
         end
         else begin
@@ -183,10 +157,10 @@ always @(posedge clk) begin
         if (rst) begin
                 lock_data <= 1'b0;
         end
-        else if (wait_addr_ok & g_flush & inst_sram_addr_ok | lock_addr & inst_sram_addr_ok | wait_data_ok & g_flush & ~inst_sram_data_ok) begin
+        else if (wait_addr_ok & g_flush & icache_addr_ok | lock_addr & icache_addr_ok | wait_data_ok & g_flush & ~icache_data_ok) begin
                 lock_data <= 1'b1;
         end
-        else if (lock_data & inst_sram_data_ok) begin 
+        else if (lock_data & icache_data_ok) begin 
                 lock_data <= 1'b0;
         end
         else begin
@@ -198,7 +172,7 @@ always @(posedge clk) begin
         if (rst) begin
                 IR <= 32'b0;
         end
-        else if (wait_data_ok & inst_sram_data_ok) begin
+        else if (wait_data_ok & icache_data_ok) begin
                 IR <= inst;
         end
         else begin
@@ -218,4 +192,16 @@ always @(posedge clk) begin
         end
 end
 
+always @(posedge clk) begin
+        if (rst) begin
+                cacheable <= 1'b0;
+        end
+        else if (nxt_is_wait_addr_ok) begin
+                cacheable <= pc_cacheable;
+        end
+        else begin
+                cacheable <= cacheable;
+        end
+end
+
 endmodule
diff --git a/MEM.v b/MEM.v
index 919ba0a..6af9b20 100644
--- a/MEM.v
+++ b/MEM.v
@@ -5,7 +5,7 @@ module MEM (
         output  wire            MEM_allowin,
         // EX -> MEM
         input   wire            EX_to_MEM,
-        input   wire [262:0]    EX_to_MEM_zip,
+        input   wire [263:0]    EX_to_MEM_zip,
         input   wire [ 14:0]    EX_except_zip,
         // MEM -> WB
         output  wire            MEM_to_WB,
@@ -17,14 +17,14 @@ module MEM (
         /// mem
         output  wire            write_en,
         output  wire [  3:0]    write_we,
-        output  wire [  1:0]    write_size,
+        // output  wire [  1:0]    write_size,
         output  wire [ 31:0]    write_addr,
         output  wire [ 31:0]    write_data,
-
+        output  wire            cacheable,
         // top -> MEM
         /// data_sram
-        input   wire            data_sram_addr_ok,
-        input   wire            data_sram_data_ok,
+        input   wire            dcache_addr_ok,
+        input   wire            dcache_data_ok,
         input   wire [ 31:0]    read_data,
         /// flush
         input   wire            flush,
@@ -38,10 +38,10 @@ module MEM (
         output  wire            MEM_is_load
 );
 
-reg  [262:0]    EX_to_MEM_reg;
+reg  [263:0]    EX_to_MEM_reg;
 always @(posedge clk) begin
         if (rst) begin
-                EX_to_MEM_reg <= 263'b0;
+                EX_to_MEM_reg <= 264'b0;
         end
         else if (EX_to_MEM) begin
                 EX_to_MEM_reg <= EX_to_MEM_zip;
@@ -127,6 +127,19 @@ wire            csr_we;
 wire [31:0]     csr_wmask;
 wire [31:0]     csr_wvalue;
 
+reg  [31:0]     rf_wdata_LOAD_reg;
+always @(posedge clk) begin
+        if (rst) begin
+                rf_wdata_LOAD_reg <= 32'b0;
+        end
+        else if (wait_data_ok & dcache_data_ok) begin
+                rf_wdata_LOAD_reg <= rf_wdata_LOAD;
+        end
+        else begin
+                rf_wdata_LOAD_reg <= rf_wdata_LOAD_reg;
+        end
+end
+
 assign front_valid = valid & gr_we;
 assign front_addr = rf_waddr;
 assign front_data = rf_wdata;
@@ -159,7 +172,7 @@ always @(posedge clk) begin
         else if (init & valid & (res_from_mem | mem_we) & ~(|EX_except_reg)) begin
                 wait_addr_ok <= 1'b1;
         end
-        else if (wait_addr_ok & data_sram_addr_ok) begin
+        else if (wait_addr_ok & dcache_addr_ok) begin
                 wait_addr_ok <= 1'b0;
         end
         else begin
@@ -171,10 +184,10 @@ always @(posedge clk) begin
         if (rst | flush) begin
                 wait_data_ok <= 1'b0;
         end
-        else if (wait_addr_ok & data_sram_addr_ok) begin
+        else if (wait_addr_ok & dcache_addr_ok) begin
                 wait_data_ok <= 1'b1;
         end
-        else if (wait_data_ok & data_sram_data_ok) begin
+        else if (wait_data_ok & dcache_data_ok) begin
                 wait_data_ok <= 1'b0;
         end
         else begin
@@ -186,7 +199,7 @@ always @(posedge clk) begin
         if (rst | flush) begin
                 readygo <= 1'b0;
         end
-        else if (init & valid & (~res_from_mem & ~mem_we | (|EX_except_reg)) | wait_data_ok & data_sram_data_ok) begin
+        else if (init & valid & (~res_from_mem & ~mem_we | (|EX_except_reg)) | wait_data_ok & dcache_data_ok) begin
                 readygo <= 1'b1;
         end
         else if (readygo & WB_allowin) begin
@@ -203,7 +216,8 @@ assign  {
         EX_to_MEM_valid, pc, IR, 
         inst_ld_b, inst_ld_bu, inst_ld_h, inst_ld_hu, inst_ld_w, 
         inst_st_b, inst_st_h, inst_st_w, 
-        mem_we, res_from_mem, gr_we, rkd_value, rf_waddr, alu_result, is_csr, write_addr,
+        mem_we, res_from_mem, gr_we, rkd_value, rf_waddr, 
+        alu_result, is_csr, write_addr, cacheable,
         inst_tlbsrch, inst_tlbrd, inst_tlbwr, inst_tlbfill, inst_invtlb,
         csr_re, csr_we, csr_wmask, csr_wvalue, csr_num
 } = EX_to_MEM_reg;
@@ -232,7 +246,7 @@ assign rf_wdata_LOAD    = inst_ld_b?  rf_wdata_ld_b :
                           inst_ld_hu? rf_wdata_ld_hu:
                           read_data;
 
-assign rf_wdata         = res_from_mem ? rf_wdata_LOAD : alu_result;
+assign rf_wdata         = res_from_mem ? rf_wdata_LOAD_reg : alu_result;
 
 assign write_en         = wait_addr_ok;
 
@@ -248,7 +262,7 @@ assign write_we         = {4{wait_addr_ok}} &
                           inst_st_w? 4'b1111:
                           4'b0000);
 
-assign write_size       = {(inst_ld_w | inst_st_w), (inst_ld_h | inst_ld_hu | inst_st_h)};
+// assign write_size       = {(inst_ld_w | inst_st_w), (inst_ld_h | inst_ld_hu | inst_st_h)};
                         
 assign write_data       = inst_st_b? {4{rkd_value[7:0]}}:
                           inst_st_h? {2{rkd_value[15:0]}}:
diff --git a/bridge.v b/bridge.v
index ff74623..c533b27 100644
--- a/bridge.v
+++ b/bridge.v
@@ -1,111 +1,113 @@
 module bridge(
-    input           aclk,
-    input           aresetn,
-
-    input           inst_sram_req,
-    input           inst_sram_wr,
-    input  [1:0]    inst_sram_size,
-    input  [31:0]   inst_sram_addr,
-    input  [3:0]    inst_sram_wstrb,
-    input  [31:0]   inst_sram_wdata,
-    output [31:0]   inst_sram_rdata,
-    output          inst_sram_addr_ok,
-    output          inst_sram_data_ok,
-
-    input           data_sram_req,
-    input           data_sram_wr,
-    input  [1:0]    data_sram_size,
-    input  [31:0]   data_sram_addr,
-    input  [3:0]    data_sram_wstrb,
-    input  [31:0]   data_sram_wdata,
-    output [31:0]   data_sram_rdata,
-    output          data_sram_addr_ok,
-    output          data_sram_data_ok,
-
-
-    // ar    读请求通道
-    output reg[3:0]    arid,
-    output reg[31:0]   araddr,
-    output    [7:0]    arlen,
-    output reg[2:0]    arsize,    
-    output    [1:0]    arburst,
-    output    [1:0]    arlock,
-    output    [3:0]    arcache,
-    output    [2:0]    arprot,
-    output             arvalid, 
-    input              arready,
-    // r  读响应通道
-    input  [3:0]       rid,
-    input  [31:0]      rdata,
-    input  [1:0]       rresp,
-    input              rlast,
-    input              rvalid,
-    output             rready,
-
-    // aw  写请求通道
-    output    [3:0]    awid,
-    output reg[31:0]   awaddr,
-    output    [7:0]    awlen,
-    output reg[2:0]    awsize,
-    output    [1:0]    awburst,
-    output    [1:0]    awlock,
-    output    [3:0]    awcache,
-    output    [2:0]    awprot,
-    output             awvalid,
-    input              awready,
-
-    // w  写数据通道
-    output    [3:0]    wid,
-    output reg[31:0]   wdata,
-    output reg[3:0]    wstrb,
-    output             wlast,
-    output             wvalid,
-    input              wready,
-
-    // b  写响应通道
-    input  [3:0]       bid,
-    input  [1:0]       bresp,
-    input              bvalid,
-    output             bready
+        input   wire            aclk,
+        input   wire            aresetn,
+
+        // ICache 读接口
+        input   wire            icache_rd_req,
+        input   wire [  2:0]    icache_rd_type,
+        input   wire [ 31:0]    icache_rd_addr,
+        output  wire            icache_rd_rdy,
+        output  wire            icache_ret_valid,
+        output  wire            icache_ret_last,
+        output  wire [ 31:0]    icache_ret_data,
+        
+        // DCache 读接口
+        input   wire            dcache_rd_req,
+        input   wire [  2:0]    dcache_rd_type,
+        input   wire [ 31:0]    dcache_rd_addr,
+        output  wire            dcache_rd_rdy,
+        output  wire            dcache_ret_valid,
+        output  wire            dcache_ret_last,
+        output  wire [ 31:0]    dcache_ret_data,
+        
+        // DCache 写接口
+        input   wire            dcache_wr_req,
+        input   wire [  2:0]    dcache_wr_type,
+        input   wire [ 31:0]    dcache_wr_addr,
+        input   wire [  3:0]    dcache_wr_wstrb,
+        input   wire [127:0]    dcache_wr_data,
+        output  wire            dcache_wr_rdy,
+
+        // ar 读请求通道
+        output  reg  [  3:0]    arid,
+        output  reg  [ 31:0]    araddr,
+        output  reg  [  7:0]    arlen,
+        output  wire [  2:0]    arsize,    
+        output  wire [  1:0]    arburst,
+        output  wire [  1:0]    arlock,
+        output  wire [  3:0]    arcache,
+        output  wire [  2:0]    arprot,
+        output  wire            arvalid, 
+        input   wire            arready,
+        
+        // r 读响应通道
+        input   wire [  3:0]    rid,
+        input   wire [ 31:0]    rdata,
+        input   wire [  1:0]    rresp,
+        input   wire            rlast,
+        input   wire            rvalid,
+        output  wire            rready,
+
+        // aw 写请求通道
+        output  wire [  3:0]    awid,
+        output  reg  [ 31:0]    awaddr,
+        output  reg  [  7:0]    awlen,
+        output  reg  [  2:0]    awsize,
+        output  wire [  1:0]    awburst,
+        output  wire [  1:0]    awlock,
+        output  wire [  3:0]    awcache,
+        output  wire [  2:0]    awprot,
+        output  wire            awvalid,
+        input   wire            awready,
+
+        // w 写数据通道
+        output  wire [  3:0]    wid,
+        output  reg  [ 31:0]    wdata,
+        output  reg  [  3:0]    wstrb,
+        output  wire            wlast,
+        output  wire            wvalid,
+        input   wire            wready,
+
+        // b 写响应通道
+        input   wire [  3:0]    bid,
+        input   wire [  1:0]    bresp,
+        input   wire            bvalid,
+        output  wire            bready
 );
 
+// Cache 请求信号
 wire rinst_req;
-wire winst_req;
 wire rdata_req;
 wire wdata_req;
 
-// 读写请求
-assign rinst_req = inst_sram_req & ~inst_sram_wr;      
-assign winst_req = inst_sram_req & inst_sram_wr;
-assign rdata_req = data_sram_req & ~data_sram_wr;
-assign wdata_req = data_sram_req & data_sram_wr;
+assign rinst_req = icache_rd_req;
+assign rdata_req = dcache_rd_req;
+assign wdata_req = dcache_wr_req;
 
+// 状态机常量定义
+localparam  ar_init         = 3'b001,
+            ar_wait         = 3'b010,
+            ar_req          = 3'b100,
 
-            //读请求状态机
-localparam  ar_wait         = 2'b01,
-            ar_req          = 2'b10,
+            r_wait          = 4'b0001,
+            r_start         = 4'b0010,  
+            r_reading       = 4'b0100, 
+            r_done          = 4'b1000,
 
-            //读响应状态机
-            r_wait          = 3'b001,
-            r_read          = 3'b010,
-            r_done          = 3'b100,
-
-            //写请求、数据状态机
             w_wait          = 5'b00001,
             w_wait_aw_w     = 5'b00010,
             w_wait_w        = 5'b00100,
             w_wait_aw       = 5'b01000,
             w_done          = 5'b10000,
 
-            //写响应状态机
             b_wait          = 2'b01,
             b_done          = 2'b10;
 
-reg [1:0] ar_cur_state;
-reg [1:0] ar_next_state;
+reg [2:0] ar_cur_state;
+reg [2:0] ar_next_state;
 
-reg [2:0] r_cur_state;
-reg [2:0] r_next_state;
+reg [3:0] r_cur_state;
+reg [3:0] r_next_state;
 
 reg [4:0] w_cur_state;
 reg [4:0] w_next_state;
@@ -115,10 +117,12 @@ reg [1:0] b_next_state;
 
 reg [1:0]  r_cnt;
 reg [3:0]  rid_reg;
-reg [31:0] inst_rdata_reg;
-reg [31:0] data_rdata_reg;
 reg [31:0] rdata_buffer [1:0];
-// reg [3:0]  rid_buffer   [3:0];
+
+// 写 Burst 相关寄存器
+reg [1:0]   wdata_index;
+reg [127:0] dcache_wr_data_r;
+reg [3:0]   dcache_wr_wstrb_r;
 
 wire reset;
 assign reset = ~aresetn;
@@ -127,57 +131,67 @@ wire need_wait;
 assign need_wait = (araddr == awaddr) & (|w_cur_state[4:1]);
 
 // read_buffer
-always @(posedge aclk)begin
-    if(reset)begin
+always @(posedge aclk) begin
+    if(reset) begin
         rdata_buffer[0] <= 32'b0;
         rdata_buffer[1] <= 32'b0;
     end
-    else if(rready & rvalid)begin
+    else if(rready & rvalid) begin
         rdata_buffer[rid[0]] <= rdata;
     end
 end
 
- always @(posedge aclk) begin
-        if(reset)
-            r_cnt <= 2'b0;
-        else if(arvalid & arready & rvalid & rready)
-            r_cnt <= r_cnt;
-        else if(arvalid & arready)
-            r_cnt <= r_cnt + 2'b1;
-        else if(rvalid & rready)
-            r_cnt <= r_cnt - 2'b1;
-    end
+// r_cnt
+always @(posedge aclk) begin
+    if(reset)
+        r_cnt <= 2'b0;
+    else if(arvalid & arready & rvalid & rready & rlast)
+        r_cnt <= r_cnt;
+    else if(arvalid & arready)
+        r_cnt <= r_cnt + 2'b1;
+    else if(rvalid & rready & rlast)
+        r_cnt <= r_cnt - 2'b1;
+end
 
-// 读请求状态机
-always @(posedge aclk)begin
+// 读请求状态机 
+always @(posedge aclk) begin
     if(reset)
-        ar_cur_state <= ar_wait;
+        ar_cur_state <= ar_init;
     else
         ar_cur_state <= ar_next_state;
 end
 
 always @(*) begin
     case(ar_cur_state)
-        ar_wait: begin
-            if(reset | need_wait)
-                ar_next_state = ar_wait;
-            else if(rinst_req | rdata_req)
+        ar_init: begin
+            if(reset)
+                ar_next_state = ar_init;
+            else if(rdata_req)
+                ar_next_state = ar_wait;   
+            else if(rinst_req)
                 ar_next_state = ar_req;
             else
+                ar_next_state = ar_init;
+        end
+        ar_wait: begin 
+            if(need_wait)
                 ar_next_state = ar_wait;
+            else
+                ar_next_state = ar_req;
         end
         ar_req: begin
             if(arvalid & arready)
-                ar_next_state = ar_wait;
+                ar_next_state = ar_init;
             else
                 ar_next_state = ar_req;
         end
         default:
-            ar_next_state = ar_wait;
+            ar_next_state = ar_init;
     endcase
 end
 
-// 读响应状态机
+
+// 读响应状态机 (R Channel) - 新增reading状态以支持 Burst
 always @(posedge aclk) begin
     if(reset)
         r_cur_state <= r_wait;
@@ -189,73 +203,102 @@ always @(*) begin
     case(r_cur_state)
         r_wait: begin
             if(arvalid & arready | (|r_cnt))
-                r_next_state = r_read;
+                r_next_state = r_start;
             else
                 r_next_state = r_wait;
         end
-        r_read: begin
-            if(rvalid & rready)
-                r_next_state = r_done;
+        r_start: begin
+            if(rvalid & rready) begin
+                if(rlast)
+                    r_next_state = r_done;
+                else
+                    r_next_state = r_reading;
+            end
             else
-                r_next_state = r_read;
+                r_next_state = r_start;
+        end
+        r_reading: begin
+            if(rvalid & rready) begin
+                if(rlast)
+                    r_next_state = r_done;
+                else
+                    r_next_state = r_reading;
+            end
+            else
+                r_next_state = r_reading;
         end
         r_done:
-                r_next_state = r_wait;
+            r_next_state = r_wait;
         default:
-                r_next_state = r_wait;
+            r_next_state = r_wait;
     endcase
 end
 
-// 写请求状态机
+
+// 写请求状态机 (AW & W Channel)
 always @(posedge aclk) begin
     if(reset)
-            w_cur_state <= w_wait;
+        w_cur_state <= w_wait;
     else 
-            w_cur_state <= w_next_state;
+        w_cur_state <= w_next_state;
 end
 
 always @(*) begin
     case(w_cur_state)
         w_wait: begin
-            if(wdata_req)
-                    w_next_state = w_wait_aw_w;
+            if(dcache_wr_rdy & wdata_req)
+                w_next_state = w_wait_aw_w;
             else
-                    w_next_state = w_wait;
+                w_next_state = w_wait;
         end
         w_wait_aw_w: begin
-            if(awvalid & awready & wvalid & wready)
+            // 检查 wlast，支持多拍传输
+            if(awvalid & awready & wvalid & wready) begin
+                if(wlast)  // 地址和最后一拍数据同时握手
                     w_next_state = w_done;
-            else if(awvalid & awready)
+                else       // 地址握手了，但数据还没发完
                     w_next_state = w_wait_w;
-            else if(wvalid & wready)
+            end
+            else if(awvalid & awready)
+                w_next_state = w_wait_w;
+            else if(wvalid & wready) begin
+                if(wlast)  // 最后一拍数据握手了，但地址还没握手
                     w_next_state = w_wait_aw;
+                else       // 数据握手了，但还有后续数据
+                    w_next_state = w_wait_aw_w;  // 继续等待
+            end
             else
-                    w_next_state = w_wait_aw_w;
+                w_next_state = w_wait_aw_w;
         end
         w_wait_aw: begin
             if(awvalid & awready) 
-                    w_next_state = w_done;
+                w_next_state = w_done;
             else 
-                    w_next_state = w_wait_aw;
+                w_next_state = w_wait_aw;
         end
         w_wait_w: begin
-            if(wvalid & wready)
+            // 检查 wlast，支持多拍传输
+            if(wvalid & wready) begin
+                if(wlast)  // 最后一拍数据发送完成
                     w_next_state = w_done;
-            else
+                else       // 还有后续数据，继续发送
                     w_next_state = w_wait_w;
+            end
+            else
+                w_next_state = w_wait_w;
         end
         w_done: begin
             if(bvalid & bready)
-                    w_next_state = w_wait;
+                w_next_state = w_wait;
             else
-                    w_next_state = w_done;
+                w_next_state = w_done;
         end
         default:
-                    w_next_state = w_wait;
+            w_next_state = w_wait;
     endcase
 end
 
-// 写响应状态机
+
 always @(posedge aclk) begin
     if(reset)
         b_cur_state <= b_wait;
@@ -266,7 +309,7 @@ end
 always @(*) begin
     case(b_cur_state)
         b_wait: begin
-            if(wvalid && wready)
+            if(wvalid && wready && wlast)
                 b_next_state = b_done;
             else
                 b_next_state = b_wait;
@@ -278,108 +321,154 @@ always @(*) begin
                 b_next_state = b_done;
         end
         default:
-                b_next_state = b_wait;
+            b_next_state = b_wait;
     endcase
 end
 
 
-assign arvalid = ar_cur_state[1];
-assign rready  = r_cur_state[1];
+// AXI 控制信号
+assign arvalid = ar_cur_state[2];
+assign rready  = r_cur_state[1] | r_cur_state[2];  // r_start 或 r_reading
 
 assign awvalid = w_cur_state[1] | w_cur_state[3];
 assign wvalid  = w_cur_state[1] | w_cur_state[2];
 assign bready  = w_cur_state[4];
 
-
-
-
 always @(posedge aclk) begin
     if(reset) begin
         arid <= 4'b0;
     end
     else if(ar_cur_state[0]) begin
-        arid <= {4{rdata_req}}; // 数据RAM请求优先于指令RAM
+        arid <= {3'b0, rdata_req};
     end
 end
 
-
-
 always @(posedge aclk) begin
     if(reset) begin
         araddr <= 32'b0;
     end
     else if(ar_cur_state[0]) begin
-        if (rdata_req)
-            araddr <= data_sram_addr;
-        else
-            araddr <= inst_sram_addr;
+        araddr <= rdata_req ? dcache_rd_addr : icache_rd_addr;
     end
 end
 
+assign arsize = 3'b010;
+
+// always @(posedge aclk) begin
+//     if(reset) begin
+//         arsize <= 3'b010;
+//     end
+//     else if(ar_cur_state[0]) begin
+//         arsize <= rdata_req ? {1'b0, dcache_rd_type[1:0]} : {1'b0, icache_rd_type[1:0]};
+//     end
+// end
 
 always @(posedge aclk) begin
     if(reset) begin
-        arsize <= 3'b0;
+        arlen <= 8'b0;
     end
     else if(ar_cur_state[0]) begin
-        if (rdata_req)
-            arsize <= {1'b0, data_sram_size};
-        else
-            arsize <= {1'b0, inst_sram_size};
+        arlen[1:0] <= rdata_req ? {2{dcache_rd_type[2]}} : {2{icache_rd_type[2]}};
     end
 end
 
-always  @(posedge aclk) begin
-        if(reset) begin
-                awaddr <= 32'b0;
-                awsize <= 3'b0;
-        end
-        else if(w_cur_state[0]) begin	
-                awaddr <= data_sram_wr? data_sram_addr : inst_sram_addr;
-                awsize <= data_sram_wr? {1'b0, data_sram_size} : {1'b0, inst_sram_size};
-        end
-end
-
-always  @(posedge aclk) begin
-        if(reset) begin
-                wstrb <= 4'b0;
-                wdata <= 32'b0;
-        end
-        else if(w_cur_state[0]) begin
-                wstrb <= data_sram_wstrb;
-                wdata <= data_sram_wdata;
-        end
-end
-
-assign arlen   = 8'b0;
 assign arburst = 2'b01;
 assign arlock  = 2'b0;
 assign arcache = 4'b0;
 assign arprot  = 3'b0;
 
-assign awid     = 4'b0001;
-assign awlen    = 8'b0;
-assign awburst  = 2'b01;
-assign awlock   = 2'b0;
-assign awcache  = 4'b0;
-assign awprot   = 3'b0;
+always @(posedge aclk) begin
+    if(reset) begin
+        awaddr <= 32'b0;
+        awsize <= 3'b0;
+    end
+    else if(w_cur_state[0]) begin
+        awaddr <= dcache_wr_addr;
+        awsize <= {1'b0, dcache_wr_type[1:0]};
+    end
+end
+
+always @(posedge aclk) begin
+    if(reset) begin
+        awlen <= 8'b0;
+    end
+    else if(w_cur_state[0]) begin
+        awlen[1:0] <= {2{dcache_wr_type[2]}};
+    end
+end
+
+assign awid    = 4'b0001;
+assign awburst = 2'b01;
+assign awlock  = 2'b0;
+assign awcache = 4'b0;
+assign awprot  = 3'b0;
+
+
+
+// 写数据缓存
+always @(posedge aclk) begin
+    if(reset) begin
+        dcache_wr_data_r <= 128'b0;
+        dcache_wr_wstrb_r <= 4'b0;
+    end
+    else if(w_cur_state[0]) begin
+        dcache_wr_data_r <= dcache_wr_data;
+        dcache_wr_wstrb_r <= dcache_wr_wstrb;
+    end
+end
 
-assign wid      = 4'b0001;
-assign wlast    = 1'b1;
+// 索引计数器
+always @(posedge aclk) begin
+    if(reset)
+        wdata_index <= 2'b0;
+    else if(w_cur_state[0] & ~wdata_req | w_cur_state[4] & bvalid & bready)
+        wdata_index <= 2'b0;
+    else if(wvalid & wready)
+        wdata_index <= wdata_index + 2'b1;
+end
 
+// 根据索引选择数据
 always @(posedge aclk) begin
-        if(reset)
-            rid_reg <= 4'b0;
-        else if(rvalid & rready)
-            rid_reg <= rid;
+    if(reset) begin
+        wstrb <= 4'b0;
+        wdata <= 32'b0;
+    end
+    else if(w_cur_state[0] | (wvalid & wready)) begin
+        wstrb <= dcache_wr_wstrb;
+        case(wdata_index)
+            2'b00: wdata <= dcache_wr_data[31:0];
+            2'b01: wdata <= dcache_wr_data[63:32];
+            2'b10: wdata <= dcache_wr_data[95:64];
+            2'b11: wdata <= dcache_wr_data[127:96];
+        endcase
+    end
 end
 
-assign inst_sram_rdata = rdata_buffer[0];
-assign data_sram_rdata = rdata_buffer[1];
+assign wid   = 4'b0001;
+assign wlast = dcache_rd_type[2]? &wdata_index : ~|wdata_index;
+
+
+always @(posedge aclk) begin
+    if(reset)
+        rid_reg <= 4'b0;
+    else if(rvalid & rready)
+        rid_reg <= rid;
+end
+
+
+// ICache 读接口
+assign icache_rd_rdy     = ar_cur_state[0] & ~need_wait & ~rdata_req;
+assign icache_ret_data   = rdata_buffer[0];
+assign icache_ret_valid  = ~rid_reg[0] & (|r_cur_state[3:2]);
+assign icache_ret_last   = ~rid_reg[0] & r_cur_state[3];
+
+// DCache 读接口
+assign dcache_rd_rdy     = ar_cur_state[0] & ~need_wait & rdata_req;
+assign dcache_ret_data   = rdata_buffer[1];
+assign dcache_ret_valid  = rid_reg[0] & (|r_cur_state[3:2]);
+assign dcache_ret_last   = rid_reg[0] & r_cur_state[3];
 
-assign inst_sram_addr_ok = ~arid[0] & arvalid & arready | ~awid[0] & awvalid & awready;
-assign data_sram_addr_ok =  arid[0] & arvalid & arready |  awid[0] & awvalid & awready; 
+// DCache 写接口
+assign dcache_wr_rdy     = w_cur_state[0] & b_cur_state[0];
 
-assign inst_sram_data_ok = (~rid_reg[0] & r_cur_state[2]);
-assign data_sram_data_ok =  (rid_reg[0] & r_cur_state[2]) | (bvalid & bready);
-endmodule
\ No newline at end of file
+endmodule
diff --git a/cache.v b/cache.v
new file mode 100644
index 0000000..89c04eb
--- /dev/null
+++ b/cache.v
@@ -0,0 +1,465 @@
+module cache (
+        input   wire            clk,
+        input   wire            resetn,
+        // interface to CPU
+        input   wire            valid,
+        input   wire            op, // 0: read, 1: write
+        input   wire            cacheable,
+        input   wire [  7:0]    index,
+        input   wire [ 19:0]    tag,
+        input   wire [  3:0]    offset,
+        input   wire [  3:0]    wstrb,
+        input   wire [ 31:0]    wdata,
+        output  wire            addr_ok,
+        output  wire            data_ok,
+        output  wire [ 31:0]    rdata,
+        // interface to bridge
+        output  wire            rd_req,
+        output  wire [  2:0]    rd_type,
+        output  wire [ 31:0]    rd_addr,
+        input   wire            rd_rdy,
+        input   wire            ret_valid,
+        input   wire            ret_last,
+        input   wire [ 31:0]    ret_data,
+        output  wire            wr_req,
+        output  wire [  2:0]    wr_type,
+        output  wire [ 31:0]    wr_addr,
+        output  wire [  3:0]    wr_wstrb,
+        output  wire [127:0]    wr_data,
+        input   wire            wr_rdy
+);
+// 主状态机状态
+localparam IDLE    = 5'b00001;
+localparam LOOKUP  = 5'b00010;
+localparam MISS    = 5'b00100;
+localparam REPLACE = 5'b01000;
+localparam REFILL  = 5'b10000;
+
+// Write Buffer 状态机状态
+localparam WRITEBUF_IDLE  = 2'b01;
+localparam WRITEBUF_WRITE = 2'b10;
+
+wire    check;  
+wire    keep_check;
+wire    hitwrite;
+wire    replace_write;
+
+// 状态机寄存器
+reg [4:0] current_state, next_state;
+reg [1:0] writebuf_cstate, writebuf_nstate;
+
+reg        reg_op;
+reg [ 7:0] reg_index;
+reg [19:0] reg_tag;
+reg [ 3:0] reg_offset;
+reg [ 3:0] reg_wstrb;
+reg [31:0] reg_wdata;
+reg        reg_cacheable;
+
+reg  [255:0] dirty [1:0];
+wire   replace_dirty;
+wire   cache_hit;
+wire   way0_hit;
+wire   way1_hit;
+
+// 冲突/阻塞检测信号
+wire need_pause;
+
+wire [ 7:0] data_addr;
+wire [31:0] data_wdata;
+wire [31:0] data_w0_b0_rdata, data_w0_b1_rdata, 
+        data_w0_b2_rdata, data_w0_b3_rdata, 
+        data_w1_b0_rdata, data_w1_b1_rdata, 
+        data_w1_b2_rdata, data_w1_b3_rdata;
+wire        data_w0_b0_en, data_w0_b1_en, 
+        data_w0_b2_en, data_w0_b3_en, 
+        data_w1_b0_en, data_w1_b1_en, 
+        data_w1_b2_en, data_w1_b3_en;
+wire [ 3:0] data_w0_b0_we, data_w0_b1_we, 
+        data_w0_b2_we, data_w0_b3_we, 
+        data_w1_b0_we, data_w1_b1_we, 
+        data_w1_b2_we, data_w1_b3_we;
+
+// 主状态机
+always @(posedge clk) begin
+if (~resetn) 
+        current_state <= IDLE;
+else       
+        current_state <= next_state;
+end
+
+always @(*) begin
+        case (current_state)
+                IDLE: begin
+                // 如果没有检测到冲突，且请求有效，进入 LOOKUP
+                if (valid && !need_pause) 
+                        next_state = LOOKUP;
+                else                            
+                        next_state = IDLE;
+                end
+                LOOKUP: begin
+                if (~cache_hit || ~reg_cacheable) 
+                        next_state = MISS;
+                // 流水线处理：如果命中，且新请求有效并无冲突，继续保持 LOOKUP 处理新请求
+                else if (valid && !need_pause) 
+                        next_state = LOOKUP;
+                else 
+                        next_state = IDLE;
+                end
+                MISS: begin
+                if (~reg_cacheable && reg_op && wr_rdy) 
+                        next_state = IDLE;
+                else if (wr_rdy || (~reg_cacheable && ~reg_op) || (reg_cacheable && !replace_dirty)) 
+                        next_state = REPLACE;
+                else                                
+                        next_state = MISS;
+                end
+                REPLACE: begin
+                if (rd_rdy) 
+                        next_state = REFILL;
+                else        
+                        next_state = REPLACE;
+                end
+                REFILL: begin
+                if (ret_valid && ret_last) 
+                        next_state = IDLE;
+                else                       
+                        next_state = REFILL;
+                end
+                default: next_state = IDLE;
+        endcase
+end
+
+// Write Buffer 状态机
+always @(posedge clk) begin
+        if (~resetn) 
+                writebuf_cstate <= WRITEBUF_IDLE;
+        else       
+                writebuf_cstate <= writebuf_nstate;
+end
+
+always @(*) begin
+        case (writebuf_cstate)
+                WRITEBUF_IDLE: begin
+                if ((current_state == LOOKUP) && reg_op && cache_hit)
+                        writebuf_nstate = WRITEBUF_WRITE;
+                else
+                        writebuf_nstate = WRITEBUF_IDLE;
+                end
+                WRITEBUF_WRITE: begin
+                if ((current_state == LOOKUP) && reg_op && cache_hit)
+                        writebuf_nstate = WRITEBUF_WRITE;
+                else
+                        writebuf_nstate = WRITEBUF_IDLE;
+                end
+                default: writebuf_nstate = WRITEBUF_IDLE;
+        endcase
+end
+
+
+// 任何情况都要check，如果连续lookup即为keep_check，写命中为hitwrite，读写未命中，则需要replace_write
+// check读tagv和data，hitwrite，replace_write都是写入tagv，data
+assign check = (current_state == IDLE) && valid && (~need_pause);
+assign keep_check = (current_state == LOOKUP) && valid && cache_hit && (~need_pause);
+assign hitwrite = (writebuf_cstate == WRITEBUF_WRITE);
+assign replace_write = (current_state == REFILL) && ret_valid;
+
+// need_pause 包含两种情况：
+// (1) 端口冲突：WriteBuffer 正在向一Bank 写，而新来的读请求也要读该Bank。
+// (2) 数据相关：Lookup 阶段是 Store，而新来的读请求访问同一地址 (RAW)。
+assign need_pause = valid && !op && 
+                                (current_state == LOOKUP && cache_hit && reg_op && index == reg_index && offset[3:2] == reg_offset[3:2] 
+                                || writebuf_cstate == WRITEBUF_WRITE && offset[3:2] == reg_offset[3:2]);
+
+always @(posedge clk) begin
+        if (~resetn) begin
+                reg_op <= 1'b0; reg_index <= 8'b0; reg_tag <= 20'b0;
+                reg_offset <= 4'b0; reg_wstrb <= 4'b0; reg_wdata <= 32'b0;
+                reg_cacheable <= 1'b0;
+        end
+        else if (check || keep_check) begin
+                reg_op <= op; reg_index <= index; reg_tag <= tag;
+                reg_offset <= offset; reg_wstrb <= wstrb; reg_wdata <= wdata;
+                reg_cacheable <= cacheable;
+        end
+end
+
+reg [ 1:0] refill_counter;
+always @(posedge clk) begin
+        if (~resetn) begin
+                refill_counter <= 2'b0;
+        end
+        else if (ret_valid) begin
+                if (ret_last) 
+                        refill_counter <= 2'b0; // 看到最后一条，归零
+                else 
+                        refill_counter <= refill_counter + 2'b1; // 否则累加
+        end
+end
+
+reg        hitwrite_way; 
+reg [ 1:0] hitwrite_bank;
+reg [ 7:0] hitwrite_index; 
+reg [ 3:0] hitwrite_strb; 
+reg [31:0] hitwrite_data;
+
+always @(posedge clk) begin
+        if (~resetn) begin
+                hitwrite_way <= 1'b0; hitwrite_bank <= 2'b0; hitwrite_index <= 8'b0;
+                hitwrite_strb <= 4'b0; hitwrite_data <= 32'b0;
+        end
+        else if ((current_state == LOOKUP) && reg_op && cache_hit) begin
+                hitwrite_way  <= way1_hit;
+                hitwrite_bank <= reg_offset[3:2];
+                hitwrite_index<= reg_index;
+                hitwrite_strb <= reg_wstrb;
+                hitwrite_data <= reg_wdata;
+        end
+end
+
+wire [19:0] way0_tag;
+wire [19:0] way1_tag;
+wire        way0_v;
+wire        way1_v;
+wire [20:0] tagv_w0_rdata;
+wire [20:0] tagv_w1_rdata;
+
+assign {way0_tag, way0_v} = tagv_w0_rdata;
+assign {way1_tag, way1_v} = tagv_w1_rdata;
+assign way0_hit = way0_v && (way0_tag == reg_tag) && reg_cacheable;
+assign way1_hit = way1_v && (way1_tag == reg_tag) && reg_cacheable;
+assign cache_hit = way0_hit || way1_hit;
+wire [20:0] tagv_wdata;
+wire [ 7:0] tagv_addr;
+wire        tagv_w0_en;
+wire        tagv_w1_en;
+wire        tagv_w0_we;
+wire        tagv_w1_we;
+
+tagv_ram tagv_way0(
+        .addra(tagv_addr),
+        .clka(clk),
+        .dina(tagv_wdata),
+        .douta(tagv_w0_rdata),
+        .ena(tagv_w0_en),
+        .wea(tagv_w0_we)
+);
+tagv_ram tagv_way1(
+        .addra(tagv_addr),
+        .clka(clk),
+        .dina(tagv_wdata),
+        .douta(tagv_w1_rdata),
+        .ena(tagv_w1_en),
+        .wea(tagv_w1_we)
+);
+
+data_bank_ram data_way0_bank0(
+        .addra(data_addr),
+        .clka(clk),
+        .dina(data_wdata),
+        .douta(data_w0_b0_rdata),
+        .ena(data_w0_b0_en),
+        .wea(data_w0_b0_we)
+);
+data_bank_ram data_way0_bank1(
+        .addra(data_addr),
+        .clka(clk),
+        .dina(data_wdata),
+        .douta(data_w0_b1_rdata),
+        .ena(data_w0_b1_en),
+        .wea(data_w0_b1_we)
+);
+data_bank_ram data_way0_bank2(
+        .addra(data_addr),
+        .clka(clk),
+        .dina(data_wdata),
+        .douta(data_w0_b2_rdata),
+        .ena(data_w0_b2_en),
+        .wea(data_w0_b2_we)
+);
+data_bank_ram data_way0_bank3(
+        .addra(data_addr),
+        .clka(clk),
+        .dina(data_wdata),
+        .douta(data_w0_b3_rdata),
+        .ena(data_w0_b3_en),
+        .wea(data_w0_b3_we)
+);
+data_bank_ram data_way1_bank0(
+        .addra(data_addr),
+        .clka(clk),
+        .dina(data_wdata),
+        .douta(data_w1_b0_rdata),
+        .ena(data_w1_b0_en),
+        .wea(data_w1_b0_we)
+);
+data_bank_ram data_way1_bank1(
+        .addra(data_addr),
+        .clka(clk),
+        .dina(data_wdata),
+        .douta(data_w1_b1_rdata),
+        .ena(data_w1_b1_en),
+        .wea(data_w1_b1_we)
+);
+data_bank_ram data_way1_bank2(
+        .addra(data_addr),
+        .clka(clk),
+        .dina(data_wdata),
+        .douta(data_w1_b2_rdata),
+        .ena(data_w1_b2_en),
+        .wea(data_w1_b2_we)
+);
+data_bank_ram data_way1_bank3(
+        .addra(data_addr),
+        .clka(clk),
+        .dina(data_wdata),
+        .douta(data_w1_b3_rdata),
+        .ena(data_w1_b3_en),
+        .wea(data_w1_b3_we)
+);
+
+wire replace_way;
+reg  random_way;
+always @(posedge clk) begin
+        if(~resetn)
+                random_way <= 1'b0;
+        else if(next_state == LOOKUP)
+                random_way <= $random() % 2;
+end
+assign replace_way = random_way;
+
+assign tagv_wdata = {reg_tag, 1'b1}; // 替换时将新数据写入tagv
+assign tagv_addr  = {8{check        }} & index    |              
+                    {8{replace_write}} & reg_index;
+
+assign tagv_w0_en = check || (replace_write && (replace_way == 1'b0));
+assign tagv_w1_en = check || (replace_write && (replace_way == 1'b1));
+assign tagv_w0_we = replace_write && (replace_way == 1'b0) && (refill_counter == reg_offset[3:2]) && reg_cacheable;
+assign tagv_w1_we = replace_write && (replace_way == 1'b1) && (refill_counter == reg_offset[3:2]) && reg_cacheable;
+
+
+wire [127:0] way0_data, way1_data, replace_data;
+wire [ 31:0] way0_load_word, way1_load_word;
+wire [ 31:0] load_res;
+
+assign way0_data = {data_w0_b3_rdata, data_w0_b2_rdata, data_w0_b1_rdata, data_w0_b0_rdata};
+assign way1_data = {data_w1_b3_rdata, data_w1_b2_rdata, data_w1_b1_rdata, data_w1_b0_rdata};
+assign way0_load_word = way0_data[reg_offset[3:2]*32 +: 32];
+assign way1_load_word = way1_data[reg_offset[3:2]*32 +: 32];
+
+assign load_res = {32{way0_hit}} & way0_load_word |
+                  {32{way1_hit}} & way1_load_word |
+                  {32{replace_write}} & ret_data;// 替换回写进cache
+
+// dirty 表
+always @(posedge clk) begin
+        if (~resetn) begin
+                dirty[0] <= 256'b0;
+                dirty[1] <= 256'b0;
+        end
+        else if (hitwrite) begin
+                dirty[hitwrite_way][hitwrite_index] <= 1'b1;
+        end
+        else if (replace_write) begin
+                dirty[replace_way][reg_index] <= reg_op;
+        end
+end
+assign replace_dirty = (replace_way == 1'b0) && dirty[0][reg_index] && way0_v 
+                    || (replace_way == 1'b1) && dirty[1][reg_index] && way1_v;
+assign replace_data = replace_way? way1_data : way0_data;
+
+wire [31:0] refill_data;
+wire [31:0] rewrite_data;
+
+assign rewrite_data = {{reg_wstrb[3]? reg_wdata[31:24] : ret_data[31:24]},
+                       {reg_wstrb[2]? reg_wdata[23:16] : ret_data[23:16]},
+                       {reg_wstrb[1]? reg_wdata[15: 8] : ret_data[15: 8]},
+                       {reg_wstrb[0]? reg_wdata[ 7: 0] : ret_data[ 7: 0]}};
+// 写缺失时,要写的数据为内存旧数据叠加输入新数据，不能直接靠wstrb解决，因为wstrb为0就不再写入
+assign refill_data = ((refill_counter == reg_offset[3:2]) && reg_op)? rewrite_data : //写缺失写回混合数据
+                                                                                ret_data; //读缺失写回内存旧数据
+assign data_wdata = replace_write? refill_data :
+                    hitwrite? hitwrite_data : 32'b0;
+
+assign data_addr  = (replace_write) ? reg_index   :
+                (hitwrite           ? hitwrite_index ://hitwrite后存的数据，可能已被更新，不能直接使用寄存
+                (check              ? index       : 8'b0));
+
+assign data_w0_b0_en = check  && (offset[3:2] == 2'b00) || //此时读，不写
+                hitwrite && (hitwrite_way == 1'b0) && (hitwrite_bank == 2'b00)  || 
+                replace_write && (replace_way == 1'b0) && (refill_counter == 2'b00);
+assign data_w0_b1_en = check  && (offset[3:2] == 2'b01) ||
+                hitwrite && (hitwrite_way == 1'b0) && (hitwrite_bank == 2'b01)  ||
+                replace_write && (replace_way == 1'b0) && (refill_counter == 2'b01);
+assign data_w0_b2_en = check  && (offset[3:2] == 2'b10) ||
+                hitwrite && (hitwrite_way == 1'b0) && (hitwrite_bank == 2'b10)  ||
+                replace_write && (replace_way == 1'b0) && (refill_counter == 2'b10);
+assign data_w0_b3_en = check  && (offset[3:2] == 2'b11) ||
+                hitwrite && (hitwrite_way == 1'b0) && (hitwrite_bank == 2'b11)  ||
+                replace_write && (replace_way == 1'b0) && (refill_counter == 2'b11);
+assign data_w1_b0_en = check  && (offset[3:2] == 2'b00) ||
+                hitwrite && (hitwrite_way == 1'b1) && (hitwrite_bank == 2'b00)  ||
+                replace_write && (replace_way == 1'b1) && (refill_counter == 2'b00);
+assign data_w1_b1_en = check  && (offset[3:2] == 2'b01) ||
+                hitwrite && (hitwrite_way == 1'b1) && (hitwrite_bank == 2'b01)  ||
+                replace_write && (replace_way == 1'b1) && (refill_counter == 2'b01);
+assign data_w1_b2_en = check  && (offset[3:2] == 2'b10) ||
+                hitwrite && (hitwrite_way == 1'b1) && (hitwrite_bank == 2'b10)  ||
+                replace_write && (replace_way == 1'b1) && (refill_counter == 2'b10);
+assign data_w1_b3_en = check  && (offset[3:2] == 2'b11) ||
+                hitwrite && (hitwrite_way == 1'b1) && (hitwrite_bank == 2'b11)  ||
+                replace_write && (replace_way == 1'b1) && (refill_counter == 2'b11);
+
+assign data_w0_b0_we = {4{hitwrite && (hitwrite_way == 1'b0) && (hitwrite_bank == 2'b00)}} & hitwrite_strb |
+                {4{replace_write&& (replace_way == 1'b0) && (refill_counter == 2'b00)}};
+assign data_w0_b1_we = {4{hitwrite && (hitwrite_way == 1'b0) && (hitwrite_bank == 2'b01)}} & hitwrite_strb |
+                {4{replace_write && (replace_way == 1'b0) && (refill_counter == 2'b01)}};
+assign data_w0_b2_we = {4{hitwrite && (hitwrite_way == 1'b0) && (hitwrite_bank == 2'b10)}} & hitwrite_strb |
+                {4{replace_write && (replace_way == 1'b0) && (refill_counter == 2'b10) }};
+assign data_w0_b3_we = {4{hitwrite && (hitwrite_way == 1'b0) && (hitwrite_bank == 2'b11)}} & hitwrite_strb |
+                {4{replace_write && (replace_way == 1'b0) && (refill_counter == 2'b11)}};
+assign data_w1_b0_we = {4{hitwrite && (hitwrite_way == 1'b1) && (hitwrite_bank == 2'b00)}} & hitwrite_strb |
+                {4{replace_write && (replace_way == 1'b1) && (refill_counter == 2'b00)}};
+assign data_w1_b1_we = {4{hitwrite && (hitwrite_way == 1'b1) && (hitwrite_bank == 2'b01)}} & hitwrite_strb |
+                {4{replace_write && (replace_way == 1'b1) && (refill_counter == 2'b01)}};
+assign data_w1_b2_we = {4{hitwrite && (hitwrite_way == 1'b1) && (hitwrite_bank == 2'b10)}} & hitwrite_strb |
+                {4{replace_write && (replace_way == 1'b1) && (refill_counter == 2'b10)}};
+assign data_w1_b3_we = {4{hitwrite && (hitwrite_way == 1'b1) && (hitwrite_bank == 2'b11)}} & hitwrite_strb |
+                {4{replace_write && (replace_way == 1'b1) && (refill_counter == 2'b11)}};
+
+
+assign addr_ok = (current_state == IDLE) ||
+                 (current_state == LOOKUP) && cache_hit && valid && ~need_pause;
+assign data_ok = (current_state == LOOKUP) && cache_hit || 
+                 (current_state == LOOKUP) && reg_op    ||
+                 (current_state == REFILL) && ret_valid && (reg_cacheable && (refill_counter == reg_offset[3:2]) || ~reg_cacheable) && ~reg_op;
+assign rdata   = load_res;
+
+// AXI 
+assign rd_req = (current_state == REPLACE) && (reg_cacheable || ~reg_op);
+assign rd_type = reg_cacheable? 3'b100 : 3'b010;
+assign rd_addr = reg_cacheable? {reg_tag, reg_index, 4'b0000} : 
+                            {reg_tag, reg_index, reg_offset};
+
+// reg reg_wr_req;
+// always @(posedge clk) begin
+//         if (!resetn) begin
+//                 reg_wr_req <= 1'b0;
+//         end
+//         else if (current_state == MISS && next_state == REPLACE) begin
+//                 reg_wr_req <= 1'b1;
+//         end
+//         else if (wr_rdy) begin
+//                 reg_wr_req <= 1'b0;
+//         end
+// end
+
+assign wr_req = (current_state == MISS) && (replace_dirty || (~reg_cacheable && reg_op));
+assign wr_type = reg_cacheable? 3'b100 : 3'b010;
+assign wr_addr = ~reg_cacheable? {reg_tag, reg_index, reg_offset} :
+                 replace_way? {way1_tag, reg_index, 4'b0000} :
+                              {way0_tag, reg_index, 4'b0000};
+assign wr_wstrb = reg_cacheable? 4'b1111 : reg_wstrb;
+assign wr_data = reg_cacheable? replace_data : {96'b0, reg_wdata};
+
+endmodule
\ No newline at end of file
diff --git a/mmu.v b/mmu.v
index 7f26aa7..8a7309f 100644
--- a/mmu.v
+++ b/mmu.v
@@ -1,44 +1,49 @@
 `include "macros.h"
 
 module mmu(
-        input  wire             mem_we, // 0: read, 1: write
-        input  wire             mmu_en,
-        input  wire [31:0]      vaddr,
-        output wire [31:0]      paddr,
+        input   wire            mem_we, // 0: read, 1: write
+        input   wire            mmu_en,
+        input   wire            is_if, // 1: instruction fetch, 0: data access
+        input   wire [31:0]     vaddr,
+        output  wire [31:0]     paddr,
+        output  wire            cacheable,
 
-        output wire [18:0]      s_vppn,
-        output wire             s_va_bit12,
-        output wire [9:0]       s_asid,
-        input  wire             s_found,
-        input  wire [3:0]       s_index,
-        input  wire [19:0]      s_ppn,
-        input  wire [5:0]       s_ps,
-        input  wire [1:0]       s_plv,
-        input  wire [1:0]       s_mat,
-        input  wire             s_d,
-        input  wire             s_v,
+        output  wire [18:0]     s_vppn,
+        output  wire            s_va_bit12,
+        output  wire [ 9:0]     s_asid,
+        input   wire            s_found,
+        input   wire [ 3:0]     s_index,
+        input   wire [19:0]     s_ppn,
+        input   wire [ 5:0]     s_ps,
+        input   wire [ 1:0]     s_plv,
+        input   wire [ 1:0]     s_mat,
+        input   wire            s_d,
+        input   wire            s_v,
 
-        input  wire [31:0]      csr_asid_data,
-        input  wire [31:0]      csr_crmd_data,
-        input  wire [31:0]      csr_dmw0_data,
-        input  wire [31:0]      csr_dmw1_data,
+        input   wire [31:0]     csr_asid_data,
+        input   wire [31:0]     csr_crmd_data,
+        input   wire [31:0]     csr_dmw0_data,
+        input   wire [31:0]     csr_dmw1_data,
 
-        output wire             except_tlbr,
-        output wire             except_pif,
-        output wire             except_pis,
-        output wire             except_pil,
-        output wire             except_pme,
-        output wire             except_ppi
+        output  wire            except_tlbr,
+        output  wire            except_pif,
+        output  wire            except_pis,
+        output  wire            except_pil,
+        output  wire            except_pme,
+        output  wire            except_ppi
 );
 wire            csr_crmd_da, csr_crmd_pg;
 wire  [4:0]     csr_crmd_plv;
+wire  [1:0]     csr_crmd_datf, csr_crmd_datm;
 wire            direct_translate, direct_map, tlb_map;
 wire            hit_dmw0, hit_dmw1;
 wire  [31:0]    tlb_paddr;
 
-assign csr_crmd_da   = csr_crmd_data[3];
-assign csr_crmd_pg   = csr_crmd_data[4];
-assign csr_crmd_plv  = {3'b0, csr_crmd_data[1:0]};
+assign csr_crmd_da   = csr_crmd_data[`CSR_CRMD_DA];
+assign csr_crmd_pg   = csr_crmd_data[`CSR_CRMD_PG];
+assign csr_crmd_plv  = {3'b0, csr_crmd_data[`CSR_CRMD_PLV]};
+assign csr_crmd_datf = csr_crmd_data[`CSR_CRMD_DATF];
+assign csr_crmd_datm = csr_crmd_data[`CSR_CRMD_DATM];
 
 assign direct_translate =  csr_crmd_da & ~csr_crmd_pg;
 assign direct_map       = ~csr_crmd_da &  csr_crmd_pg;
@@ -59,6 +64,11 @@ assign paddr =  direct_translate? vaddr :
                 hit_dmw0 ? {csr_dmw0_data[27:25], vaddr[28:0]} :
                 hit_dmw1 ? {csr_dmw1_data[27:25], vaddr[28:0]} :
                 tlb_paddr;
+
+assign cacheable = direct_translate? (is_if? csr_crmd_datf == 2'b01 : csr_crmd_datm == 2'b01) :
+                   hit_dmw0? csr_dmw0_data[`CSR_DMW_MAT] == 2'b01 :
+                   hit_dmw1? csr_dmw1_data[`CSR_DMW_MAT] == 2'b01 :
+                   (s_mat == 2'b01);
                 
 assign except_tlbr = mmu_en & tlb_map & ~s_found;
 assign except_pif  = mmu_en & tlb_map &  s_found & ~s_v;
diff --git a/mycpu_top.v b/mycpu_top.v
index bf54fad..285a3fa 100644
--- a/mycpu_top.v
+++ b/mycpu_top.v
@@ -1,97 +1,139 @@
 module mycpu_top(
-    input  wire        aclk,
-    input  wire        aresetn,
-
-    // ar    读请求通道
-    output    [3:0]    arid,
-    output    [31:0]   araddr,
-    output    [7:0]    arlen,
-    output    [2:0]    arsize,    
-    output    [1:0]    arburst,
-    output    [1:0]    arlock,
-    output    [3:0]    arcache,
-    output    [2:0]    arprot,
-    output             arvalid, 
-    input              arready,
-    // r  读响应通道
-    input  [3:0]       rid,
-    input  [31:0]      rdata,
-    input  [1:0]       rresp,
-    input              rlast,
-    input              rvalid,
-    output             rready,
-
-    // aw  写请求通道
-    output    [3:0]    awid,
-    output    [31:0]   awaddr,
-    output    [7:0]    awlen,
-    output    [2:0]    awsize,
-    output    [1:0]    awburst,
-    output    [1:0]    awlock,
-    output    [3:0]    awcache,
-    output    [2:0]    awprot,
-    output             awvalid,
-    input              awready,
-
-    // w  写数据通道
-    output    [3:0]    wid,
-    output    [31:0]   wdata,
-    output    [3:0]    wstrb,
-    output             wlast,
-    output             wvalid,
-    input              wready,
-
-    // b  写响应通道
-    input  [3:0]       bid,
-    input  [1:0]       bresp,
-    input              bvalid,
-    output             bready,
-
-    // trace debug interface
-    output wire [31:0] debug_wb_pc,
-    output wire [ 3:0] debug_wb_rf_we,
-    output wire [ 4:0] debug_wb_rf_wnum,
-    output wire [31:0] debug_wb_rf_wdata
+        input   wire            aclk,
+        input   wire            aresetn,
+
+        // ar    读请求通道
+        output  wire [ 3:0]     arid,
+        output  wire [31:0]     araddr,
+        output  wire [ 7:0]     arlen,
+        output  wire [ 2:0]     arsize,    
+        output  wire [ 1:0]     arburst,
+        output  wire [ 1:0]     arlock,
+        output  wire [ 3:0]     arcache,
+        output  wire [ 2:0]     arprot,
+        output  wire            arvalid, 
+        input   wire            arready,
+        // r  读响应通道
+        input   wire [ 3:0]     rid,
+        input   wire [31:0]     rdata,
+        input   wire [ 1:0]     rresp,
+        input   wire            rlast,
+        input   wire            rvalid,
+        output  wire            rready,
+
+        // aw  写请求通道
+        output  wire [ 3:0]     awid,
+        output  wire [31:0]     awaddr,
+        output  wire [ 7:0]     awlen,
+        output  wire [ 2:0]     awsize,
+        output  wire [ 1:0]     awburst,
+        output  wire [ 1:0]     awlock,
+        output  wire [ 3:0]     awcache,
+        output  wire [ 2:0]     awprot,
+        output  wire            awvalid,
+        input   wire            awready,
+
+        // w  写数据通道
+        output  wire [ 3:0]     wid,
+        output  wire [31:0]     wdata,
+        output  wire [ 3:0]     wstrb,
+        output  wire            wlast,
+        output  wire            wvalid,
+        input   wire            wready,
+
+        // b  写响应通道
+        input   wire [ 3:0]     bid,
+        input   wire [ 1:0]     bresp,
+        input   wire            bvalid,
+        output  wire            bready,
+
+        // trace debug interface
+        output  wire [31:0]     debug_wb_pc,
+        output  wire [ 3:0]     debug_wb_rf_we,
+        output  wire [ 4:0]     debug_wb_rf_wnum,
+        output  wire [31:0]     debug_wb_rf_wdata
 );
 
 wire            clk;
 reg             reset;
 
 assign clk = aclk;
-always @(posedge clk) 
-    reset <= ~aresetn;
+always @(posedge clk) begin 
+        reset <= ~aresetn;
+end
 
 // counter 
 reg  [63:0]     counter;
 always @(posedge clk) begin
-    if (reset) begin
-        counter <= 64'b0;
-    end
-    else begin
-        counter <= counter + 64'b1;
-    end
+        if (reset) begin
+                counter <= 64'b0;
+        end
+        else begin
+                counter <= counter + 64'b1;
+        end
 end
 
-// SRAM
-wire            inst_sram_req;
-wire            inst_sram_wr;
-wire [ 1:0]     inst_sram_size;
-wire [31:0]     inst_sram_addr;
-wire [ 3:0]     inst_sram_wstrb;
-wire [31:0]     inst_sram_wdata;
-wire [31:0]     inst_sram_rdata;
-wire            inst_sram_addr_ok;
-wire            inst_sram_data_ok;
-
-wire            data_sram_req;
-wire            data_sram_wr;
-wire [ 1:0]     data_sram_size;
-wire [31:0]     data_sram_addr;
-wire [ 3:0]     data_sram_wstrb;
-wire [31:0]     data_sram_wdata;
-wire [31:0]     data_sram_rdata;
-wire            data_sram_addr_ok;
-wire            data_sram_data_ok;
+// I-Cache <-> CPU
+wire            icache_valid;
+wire            icache_op;
+wire            icache_cacheable;
+wire [ 7:0]     icache_index;
+wire [19:0]     icache_tag;
+wire [ 3:0]     icache_offset;
+wire [ 3:0]     icache_wstrb;
+wire [31:0]     icache_wdata;
+wire            icache_addr_ok;
+wire            icache_data_ok;
+wire [31:0]     icache_rdata;
+
+// I-Cache read
+wire            icache_rd_req;
+wire [ 2:0]     icache_rd_type;
+wire [31:0]     icache_rd_addr;
+wire            icache_rd_rdy;
+wire            icache_ret_valid;
+wire            icache_ret_last;
+wire [31:0]     icache_ret_data;
+
+// D-Cache <-> CPU
+wire            dcache_valid;
+wire            dcache_op;
+wire            dcache_cacheable;
+wire [ 7:0]     dcache_index;
+wire [19:0]     dcache_tag;
+wire [ 3:0]     dcache_offset;
+wire [ 3:0]     dcache_wstrb;
+wire [31:0]     dcache_wdata;
+wire            dcache_addr_ok;
+wire            dcache_data_ok;
+wire [31:0]     dcache_rdata;
+
+// D-Cache read
+wire            dcache_rd_req;
+wire [ 2:0]     dcache_rd_type;
+wire [31:0]     dcache_rd_addr;
+wire            dcache_rd_rdy;
+wire            dcache_ret_valid;
+wire            dcache_ret_last;
+wire [31:0]     dcache_ret_data;
+
+// D-Cache write
+wire            dcache_wr_req;
+wire [  2:0]    dcache_wr_type;
+wire [ 31:0]    dcache_wr_addr;
+wire [  3:0]    dcache_wr_wstrb;
+wire [127:0]    dcache_wr_data;
+wire            dcache_wr_rdy;
+
+wire            inst_req;
+wire [ 31:0]    pc_paddr;
+wire            pc_cacheable;
+wire            addr_cacheable;
+wire            data_req;
+wire [  3:0]    data_wstrb;
+wire [ 31:0]    data_waddr;
+wire [ 31:0]    data_wdata;
+wire [ 31:0]    data_rdata;
 
 // allowin
 wire            ID_allowin;
@@ -102,7 +144,7 @@ wire            WB_allowin;
 // internal pipeline zipes
 wire [ 65:0]    IF_to_ID_zip;
 wire [283:0]    ID_to_EX_zip;
-wire [262:0]    EX_to_MEM_zip;
+wire [263:0]    EX_to_MEM_zip;
 wire [186:0]    MEM_to_WB_zip;
 
 // IF <-> ID signals
@@ -163,10 +205,10 @@ wire [31:0]     csr_tlbehi_data;
 wire [31:0]     csr_tlbelo0_data;
 wire [31:0]     csr_tlbelo1_data;
 
-wire [  3:0]    IF_except_zip;
-wire [  8:0]    ID_except_zip;
-wire [ 14:0]    EX_except_zip;
-wire [ 46:0]    MEM_except_zip;
+wire [ 3:0]     IF_except_zip;
+wire [ 8:0]     ID_except_zip;
+wire [14:0]     EX_except_zip;
+wire [46:0]     MEM_except_zip;
 
 wire [31:0]     wb_vaddr;
 wire [31:0]     ex_vaddr;
@@ -193,555 +235,635 @@ wire            except_ppi_mem;
 
 wire            mem_we;
 wire            mmu_en;
-wire [31:0]     vaddr_ex;
 wire [31:0]     addr_trans;
 
-wire [31:0] csr_dmw0_data;
-wire [31:0] csr_dmw1_data;
-wire [31:0] csr_asid_data;
-wire [31:0] csr_crmd_data;
-
-wire [18:0] s0_vppn;
-wire        s0_va_bit12;
-wire [9:0]  s0_asid;
-wire        s0_found;
-wire [3:0]  s0_index;
-wire [19:0] s0_ppn;
-wire [5:0]  s0_ps;     
-wire [1:0]  s0_plv;
-wire [1:0]  s0_mat;
-wire        s0_d;
-wire        s0_v;
-
-wire [18:0] s1_vppn;
-wire        s1_va_bit12;
-wire [9:0]  s1_asid;
-wire        s1_found;
-wire [3:0]  s1_index;
-wire [19:0] s1_ppn;
-wire [5:0]  s1_ps;     
-wire [1:0]  s1_plv;
-wire [1:0]  s1_mat;
-wire        s1_d;
-wire        s1_v;
-
-wire [3:0]  r_index;
-wire        r_e;
-wire [18:0] r_vppn;
-wire [5:0]  r_ps;
-wire [9:0]  r_asid;
-wire        r_g;
-wire [19:0] r_ppn0;
-wire [1:0]  r_plv0;
-wire [1:0]  r_mat0;
-wire        r_d0;
-wire        r_v0;
-wire [19:0] r_ppn1;
-wire [1:0]  r_plv1;
-wire [1:0]  r_mat1;
-wire        r_d1;
-wire        r_v1;
-
-wire        invtlb_valid;
-wire [4:0]  invtlb_op;
-wire        tlb_we;
-wire [3:0]  w_index;
-wire        w_e;
-wire [18:0] w_vppn;
-wire [5:0]  w_ps;
-wire [9:0]  w_asid;
-wire        w_g;
-wire [19:0] w_ppn0;
-wire [1:0]  w_plv0;
-wire [1:0]  w_mat0;
-wire        w_d0;
-wire        w_v0;
-wire [19:0] w_ppn1;
-wire [1:0]  w_plv1;
-wire [1:0]  w_mat1;
-wire        w_d1;
-wire        w_v1;
-wire        tlb_flush;
-wire [31:0] tlb_flush_target;
+wire [31:0]     csr_dmw0_data;
+wire [31:0]     csr_dmw1_data;
+wire [31:0]     csr_asid_data;
+wire [31:0]     csr_crmd_data;
+
+wire [18:0]     s0_vppn;
+wire            s0_va_bit12;
+wire [ 9:0]     s0_asid;
+wire            s0_found;
+wire [ 3:0]     s0_index;
+wire [19:0]     s0_ppn;
+wire [ 5:0]     s0_ps;     
+wire [ 1:0]     s0_plv;
+wire [ 1:0]     s0_mat;
+wire            s0_d;
+wire            s0_v;
+
+wire [18:0]     s1_vppn;
+wire            s1_va_bit12;
+wire [ 9:0]     s1_asid;
+wire            s1_found;
+wire [ 3:0]     s1_index;
+wire [19:0]     s1_ppn;
+wire [ 5:0]     s1_ps;     
+wire [ 1:0]     s1_plv;
+wire [ 1:0]     s1_mat;
+wire            s1_d;
+wire            s1_v;
+
+wire [ 3:0]     r_index;
+wire            r_e;
+wire [18:0]     r_vppn;
+wire [ 5:0]     r_ps;
+wire [ 9:0]     r_asid;
+wire            r_g;
+wire [19:0]     r_ppn0;
+wire [ 1:0]     r_plv0;
+wire [ 1:0]     r_mat0;
+wire            r_d0;
+wire            r_v0;
+wire [19:0]     r_ppn1;
+wire [ 1:0]     r_plv1;
+wire [ 1:0]     r_mat1;
+wire            r_d1;
+wire            r_v1;
+
+wire            invtlb_valid;
+wire [ 4:0]     invtlb_op;
+wire            tlb_we;
+wire [ 3:0]     w_index;
+wire            w_e;
+wire [18:0]     w_vppn;
+wire [ 5:0]     w_ps;
+wire [ 9:0]     w_asid;
+wire            w_g;
+wire [19:0]     w_ppn0;
+wire [ 1:0]     w_plv0;
+wire [ 1:0]     w_mat0;
+wire            w_d0;
+wire            w_v0;
+wire [19:0]     w_ppn1;
+wire [ 1:0]     w_plv1;
+wire [ 1:0]     w_mat1;
+wire            w_d1;
+wire            w_v1;
+wire            tlb_flush;
+wire [31:0]     tlb_flush_target;
+
+assign flush    = ertn_flush | wb_ex | tlb_flush;
+assign flush_target     = ertn_flush? csr_era_pc : 
+                          wb_ex?      {32{except_tlbr}} & csr_tlbrentry_data | {32{~except_tlbr}} & csr_eentry_data : 
+                          tlb_flush_target;
+
+assign icache_valid     = inst_req;
+assign icache_op        = 1'b0;
+assign {
+        icache_tag, 
+        icache_index, 
+        icache_offset
+} = pc_paddr;
+
+assign dcache_valid     = data_req;
+assign dcache_op        = |data_wstrb;
+assign {
+        dcache_tag,
+        dcache_index,
+        dcache_offset
+} = data_waddr;
+assign dcache_wstrb     = data_wstrb;
+assign dcache_wdata     = data_wdata;
+assign data_rdata       = dcache_rdata;
+
+// inst_retire_reg format: { pc(32), {4{rf_wen}}(4), rf_waddr(5), rf_wdata(32) }
+assign {
+        debug_wb_pc,
+        debug_wb_rf_we,
+        debug_wb_rf_wnum,
+        debug_wb_rf_wdata
+} = wb_inst_retire;
 
 // AXI bridge instance
 bridge u_bridge (
-    .aclk(aclk),
-    .aresetn(aresetn),
-
-    .inst_sram_req(inst_sram_req),
-    .inst_sram_wr(inst_sram_wr),
-    .inst_sram_size(inst_sram_size),
-    .inst_sram_addr(inst_sram_addr),
-    .inst_sram_wstrb(inst_sram_wstrb),
-    .inst_sram_wdata(inst_sram_wdata),
-    .inst_sram_rdata(inst_sram_rdata),
-    .inst_sram_addr_ok(inst_sram_addr_ok),
-    .inst_sram_data_ok(inst_sram_data_ok),
-
-    .data_sram_req(data_sram_req),
-    .data_sram_wr(data_sram_wr),
-    .data_sram_size(data_sram_size),
-    .data_sram_addr(data_sram_addr),
-    .data_sram_wstrb(data_sram_wstrb),
-    .data_sram_wdata(data_sram_wdata),
-    .data_sram_addr_ok(data_sram_addr_ok),
-    .data_sram_rdata(data_sram_rdata),
-    .data_sram_data_ok(data_sram_data_ok),
-
-    .arid(arid),
-    .araddr(araddr),
-    .arlen(arlen),
-    .arsize(arsize),
-    .arburst(arburst),
-    .arlock(arlock),
-    .arcache(arcache),
-    .arprot(arprot),
-    .arvalid(arvalid),
-    .arready(arready),
-
-    .rid(rid),
-    .rdata(rdata),
-    .rresp(rresp),
-    .rlast(rlast),
-    .rvalid(rvalid),
-    .rready(rready),
-
-    .awid(awid),
-    .awaddr(awaddr),
-    .awlen(awlen),
-    .awsize(awsize),
-    .awburst(awburst),
-    .awlock(awlock),
-    .awcache(awcache),
-    .awprot(awprot),
-    .awvalid(awvalid),
-    .awready(awready),
-
-    .wid(wid),
-    .wdata(wdata),
-    .wstrb(wstrb),
-    .wlast(wlast),
-    .wvalid(wvalid),
-    .wready(wready),
-
-    .bid(bid),
-    .bresp(bresp),
-    .bvalid(bvalid),
-    .bready(bready)
+        .aclk(aclk),
+        .aresetn(aresetn),
+
+        .icache_rd_req(icache_rd_req),
+        .icache_rd_type(icache_rd_type),
+        .icache_rd_addr(icache_rd_addr),
+        .icache_rd_rdy(icache_rd_rdy),
+        .icache_ret_valid(icache_ret_valid),
+        .icache_ret_last(icache_ret_last),
+        .icache_ret_data(icache_ret_data),
+
+        .dcache_rd_req(dcache_rd_req),
+        .dcache_rd_type(dcache_rd_type),
+        .dcache_rd_addr(dcache_rd_addr),
+        .dcache_rd_rdy(dcache_rd_rdy),
+        .dcache_ret_valid(dcache_ret_valid),
+        .dcache_ret_last(dcache_ret_last),
+        .dcache_ret_data(dcache_ret_data),
+
+        .dcache_wr_req(dcache_wr_req),
+        .dcache_wr_type(dcache_wr_type),
+        .dcache_wr_addr(dcache_wr_addr),
+        .dcache_wr_wstrb(dcache_wr_wstrb),
+        .dcache_wr_data(dcache_wr_data),
+        .dcache_wr_rdy(dcache_wr_rdy),
+
+        .arid(arid),
+        .araddr(araddr),
+        .arlen(arlen),
+        .arsize(arsize),
+        .arburst(arburst),
+        .arlock(arlock),
+        .arcache(arcache),
+        .arprot(arprot),
+        .arvalid(arvalid),
+        .arready(arready),
+
+        .rid(rid),
+        .rdata(rdata),
+        .rresp(rresp),
+        .rlast(rlast),
+        .rvalid(rvalid),
+        .rready(rready),
+
+        .awid(awid),
+        .awaddr(awaddr),
+        .awlen(awlen),
+        .awsize(awsize),
+        .awburst(awburst),
+        .awlock(awlock),
+        .awcache(awcache),
+        .awprot(awprot),
+        .awvalid(awvalid),
+        .awready(awready),
+
+        .wid(wid),
+        .wdata(wdata),
+        .wstrb(wstrb),
+        .wlast(wlast),
+        .wvalid(wvalid),
+        .wready(wready),
+
+        .bid(bid),
+        .bresp(bresp),
+        .bvalid(bvalid),
+        .bready(bready)
 );
 
 // IF instance
 IF u_IF (
-    .clk            (clk),
-    .rst            (reset),
-    .ID_flush       (ID_flush),
-    .inst           (inst_sram_rdata),
-    .ID_flush_target(ID_pc_real),
-    .pc_paddr       (inst_sram_addr),
-    .IF_to_ID_zip   (IF_to_ID_zip),
-    .IF_except_zip  (IF_except_zip),
-    .ID_allowin     (ID_allowin),
-    .inst_sram_addr_ok     (inst_sram_addr_ok),
-    .inst_sram_data_ok     (inst_sram_data_ok),
-    .inst_sram_en   (inst_sram_req),
-    .flush          (flush),
-    .flush_target   (flush_target),
-    .IF_to_ID       (IF_to_ID),
-    .pc_next        (pc_next),
-    .pc_trans       (pc_trans),
-    .except_tlbr    (except_tlbr_if),
-    .except_pif     (except_pif),
-    .except_ppi     (except_ppi_if)
+        .clk            (clk),
+        .rst            (reset),
+        .ID_flush       (ID_flush),
+        .inst           (icache_rdata),
+        .ID_flush_target(ID_pc_real),
+        .pc_paddr       (pc_paddr),
+        .cacheable      (icache_cacheable),
+        .IF_to_ID_zip   (IF_to_ID_zip),
+        .IF_except_zip  (IF_except_zip),
+        .ID_allowin     (ID_allowin),
+        .icache_addr_ok (icache_addr_ok),
+        .icache_data_ok (icache_data_ok),
+        .pc_cacheable   (pc_cacheable),
+        .inst_req       (inst_req),
+        .flush          (flush),
+        .flush_target   (flush_target),
+        .IF_to_ID       (IF_to_ID),
+        .pc_next        (pc_next),
+        .pc_trans       (pc_trans),
+        .except_tlbr    (except_tlbr_if),
+        .except_pif     (except_pif),
+        .except_ppi     (except_ppi_if)
 );
 
 // ID instance
 ID u_ID (
-    .clk            (clk),
-    .rst            (reset),
-    .IF_to_ID_zip   (IF_to_ID_zip),
-    .IF_except_zip  (IF_except_zip),
-    .front_from_EX_valid (EX_front_valid),
-    .front_from_EX_addr  (EX_front_addr),
-    .front_from_EX_data  (EX_front_data),
-    .front_from_MEM_valid(MEM_front_valid),
-    .front_from_MEM_addr (MEM_front_addr),
-    .front_from_MEM_data (MEM_front_data),
-    .mem_done       (MEM_done),
-    .rf_rdata1      (rf_rdata1),
-    .rf_rdata2      (rf_rdata2),
-    .rf_raddr1      (rf_raddr1),
-    .rf_raddr2      (rf_raddr2),
-    .has_int        (has_int),
-    .ID_flush       (ID_flush),
-    .ID_flush_target(ID_pc_real),
-    .ID_to_EX_zip   (ID_to_EX_zip),
-    .ID_allowin     (ID_allowin),
-    .EX_allowin     (EX_allowin),
-    .flush          (flush),
-    .ID_except_zip  (ID_except_zip),
-    .IF_to_ID       (IF_to_ID),
-    .ID_to_EX       (ID_to_EX),
-    .EX_is_csr      (EX_is_csr),
-    .EX_is_load     (EX_is_load),
-    .MEM_is_csr     (MEM_is_csr),
-    .MEM_is_load    (MEM_is_load)
+        .clk            (clk),
+        .rst            (reset),
+        .IF_to_ID_zip   (IF_to_ID_zip),
+        .IF_except_zip  (IF_except_zip),
+        .front_from_EX_valid (EX_front_valid),
+        .front_from_EX_addr  (EX_front_addr),
+        .front_from_EX_data  (EX_front_data),
+        .front_from_MEM_valid(MEM_front_valid),
+        .front_from_MEM_addr (MEM_front_addr),
+        .front_from_MEM_data (MEM_front_data),
+        .mem_done       (MEM_done),
+        .rf_rdata1      (rf_rdata1),
+        .rf_rdata2      (rf_rdata2),
+        .rf_raddr1      (rf_raddr1),
+        .rf_raddr2      (rf_raddr2),
+        .has_int        (has_int),
+        .ID_flush       (ID_flush),
+        .ID_flush_target(ID_pc_real),
+        .ID_to_EX_zip   (ID_to_EX_zip),
+        .ID_allowin     (ID_allowin),
+        .EX_allowin     (EX_allowin),
+        .flush          (flush),
+        .ID_except_zip  (ID_except_zip),
+        .IF_to_ID       (IF_to_ID),
+        .ID_to_EX       (ID_to_EX),
+        .EX_is_csr      (EX_is_csr),
+        .EX_is_load     (EX_is_load),
+        .MEM_is_csr     (MEM_is_csr),
+        .MEM_is_load    (MEM_is_load)
 );
 
 // EX instance
 EX u_EX (
-    .clk            (clk),
-    .rst            (reset),
-
-    .front_valid    (EX_front_valid),
-    .front_addr     (EX_front_addr),
-    .front_data     (EX_front_data),
-    .EX_allowin     (EX_allowin),
-    .EX_is_csr      (EX_is_csr),
-    .EX_is_load     (EX_is_load),
-
-    .ID_to_EX       (ID_to_EX),
-    .ID_to_EX_zip   (ID_to_EX_zip),
-    .ID_except_zip  (ID_except_zip),
-    .EX_to_MEM      (EX_to_MEM),
-    .EX_to_MEM_zip  (EX_to_MEM_zip),
-    .EX_except_zip  (EX_except_zip),
-
-    .MEM_allowin    (MEM_allowin),
-
-    .mmu_en         (mmu_en),
-    .mem_we         (mem_we),
-    .csr_asid_data  (csr_asid_data),
-    .csr_tlbehi_data(csr_tlbehi_data),
-    .csr_tlbidx_data(csr_tlbidx_data),
-    .invtlb_valid   (invtlb_valid),
-    .invtlb_op      (invtlb_op),
-
-    .addr_trans     (addr_trans),
-    .except_tlbr    (except_tlbr_mem),
-    .except_pil     (except_pil),
-    .except_pis     (except_pis),
-    .except_pme     (except_pme),
-    .except_ppi     (except_ppi_mem),
-
-    .vaddr          (ex_vaddr),
-    .s1_asid        (s1_asid),
-    .s1_found       (s1_found),
-    .s1_index       (s1_index),
-    
-    .flush          (flush),
-    .counter        (counter)
+        .clk            (clk),
+        .rst            (reset),
+
+        .front_valid    (EX_front_valid),
+        .front_addr     (EX_front_addr),
+        .front_data     (EX_front_data),
+        .EX_allowin     (EX_allowin),
+        .EX_is_csr      (EX_is_csr),
+        .EX_is_load     (EX_is_load),
+
+        .ID_to_EX       (ID_to_EX),
+        .ID_to_EX_zip   (ID_to_EX_zip),
+        .ID_except_zip  (ID_except_zip),
+        .EX_to_MEM      (EX_to_MEM),
+        .EX_to_MEM_zip  (EX_to_MEM_zip),
+        .EX_except_zip  (EX_except_zip),
+
+        .MEM_allowin    (MEM_allowin),
+
+        .mmu_en         (mmu_en),
+        .mem_we         (mem_we),
+        .csr_asid_data  (csr_asid_data),
+        .csr_tlbehi_data(csr_tlbehi_data),
+        .csr_tlbidx_data(csr_tlbidx_data),
+        .invtlb_valid   (invtlb_valid),
+        .invtlb_op      (invtlb_op),
+
+        .addr_trans     (addr_trans),
+        .addr_cacheable (addr_cacheable),
+        .except_tlbr    (except_tlbr_mem),
+        .except_pil     (except_pil),
+        .except_pis     (except_pis),
+        .except_pme     (except_pme),
+        .except_ppi     (except_ppi_mem),
+
+        .vaddr          (ex_vaddr),
+        .s1_asid        (s1_asid),
+        .s1_found       (s1_found),
+        .s1_index       (s1_index),
+        
+        .flush          (flush),
+        .counter        (counter)
 );
 
 // MEM instance
 MEM u_MEM (
-    .clk            (clk),
-    .rst            (reset),
-    .EX_to_MEM_zip  (EX_to_MEM_zip),
-    .write_en       (data_sram_req),
-    .write_we       (data_sram_wstrb),
-    .write_size     (data_sram_size),
-    .write_addr     (data_sram_addr),
-    .write_data     (data_sram_wdata),
-    .MEM_to_WB_zip  (MEM_to_WB_zip),
-    .read_data      (data_sram_rdata),
-    .MEM_allowin    (MEM_allowin),
-    .WB_allowin     (WB_allowin),
-    .data_sram_addr_ok     (data_sram_addr_ok),
-    .data_sram_data_ok     (data_sram_data_ok),
-    .front_valid    (MEM_front_valid),
-    .front_addr     (MEM_front_addr),
-    .front_data     (MEM_front_data),
-    .MEM_done       (MEM_done),
-    .flush          (flush),
-    .EX_except_zip  (EX_except_zip),
-    .MEM_except_zip (MEM_except_zip),
-    .EX_to_MEM      (EX_to_MEM),
-    .MEM_to_WB      (MEM_to_WB),
-    .MEM_is_csr     (MEM_is_csr),
-    .MEM_is_load    (MEM_is_load)
+        .clk            (clk),
+        .rst            (reset),
+        .EX_to_MEM_zip  (EX_to_MEM_zip),
+        .write_en       (data_req),
+        .write_we       (data_wstrb),
+        .write_addr     (data_waddr),
+        .write_data     (data_wdata),
+        .cacheable      (dcache_cacheable),
+        .MEM_to_WB_zip  (MEM_to_WB_zip),
+        .read_data      (data_rdata),
+        .MEM_allowin    (MEM_allowin),
+        .WB_allowin     (WB_allowin),
+        .dcache_addr_ok     (dcache_addr_ok),
+        .dcache_data_ok     (dcache_data_ok),
+        .front_valid    (MEM_front_valid),
+        .front_addr     (MEM_front_addr),
+        .front_data     (MEM_front_data),
+        .MEM_done       (MEM_done),
+        .flush          (flush),
+        .EX_except_zip  (EX_except_zip),
+        .MEM_except_zip (MEM_except_zip),
+        .EX_to_MEM      (EX_to_MEM),
+        .MEM_to_WB      (MEM_to_WB),
+        .MEM_is_csr     (MEM_is_csr),
+        .MEM_is_load    (MEM_is_load)
 );
 
 // WB instance
 WB u_WB (
-    .clk            (clk),
-    .rst            (reset),
-
-    .MEM_to_WB      (MEM_to_WB),
-    .MEM_to_WB_zip  (MEM_to_WB_zip),
-    .MEM_except_zip (MEM_except_zip),
-    .WB_allowin     (WB_allowin),
-
-    .rf_wen         (wb_rf_wen),
-    .rf_waddr       (wb_rf_waddr),
-    .rf_wdata_final (wb_rf_wdata),
-    .inst_retire    (wb_inst_retire),
-
-    .csr_re         (csr_re),
-    .csr_num        (csr_num),
-    .csr_we         (csr_we),
-    .csr_wmask      (csr_wmask),
-    .csr_wvalue     (csr_wvalue),
-    .ertn_flush     (ertn_flush),
-    .except_tlbr    (except_tlbr),
-    .wb_pc          (wb_pc),
-    .wb_ex          (wb_ex),
-    .wb_ecode       (wb_ecode),
-    .wb_esubcode    (wb_esubcode),
-    .wb_vaddr       (wb_vaddr),
-
-    .csr_rvalue     (csr_rvalue),
-    .csr_estat_data (csr_estat_data),
-    .csr_tlbidx_data    (csr_tlbidx_data),
-    .csr_tlbehi_data    (csr_tlbehi_data),
-    .csr_tlbelo0_data   (csr_tlbelo0_data),
-    .csr_tlbelo1_data   (csr_tlbelo1_data),
-    .csr_asid_data  (csr_asid_data),
-
-    .tlb_flush      (tlb_flush),
-    .tlb_flush_target   (tlb_flush_target),
-
-    .tlbrd          (inst_tlbrd),
-    .tlbehi_wdata   (tlbehi_wdata),
-    .tlbelo0_wdata  (tlbelo0_wdata),
-    .tlbelo1_wdata  (tlbelo1_wdata),
-    .tlbidx_wdata   (tlbidx_wdata),
-    .tlbasid_wdata  (tlbasid_wdata),
-
-    .we             (tlb_we),
-    .w_index        (w_index),
-    .w_e            (w_e),
-    .w_vppn         (w_vppn),
-    .w_ps           (w_ps),
-    .w_asid         (w_asid),
-    .w_g            (w_g),
-    .w_ppn0         (w_ppn0),
-    .w_plv0         (w_plv0),
-    .w_mat0         (w_mat0),
-    .w_d0           (w_d0),
-    .w_v0           (w_v0),
-    .w_ppn1         (w_ppn1),
-    .w_plv1         (w_plv1),
-    .w_mat1         (w_mat1),
-    .w_d1           (w_d1), 
-    .w_v1           (w_v1),
-    .r_index        (r_index),
-    .r_e            (r_e),
-    .r_vppn         (r_vppn),
-    .r_ps           (r_ps),
-    .r_asid         (r_asid),
-    .r_g            (r_g),
-    .r_ppn0         (r_ppn0),
-    .r_plv0         (r_plv0),
-    .r_mat0         (r_mat0),
-    .r_d0           (r_d0),
-    .r_v0           (r_v0),
-    .r_ppn1         (r_ppn1),
-    .r_plv1         (r_plv1),
-    .r_mat1         (r_mat1),
-    .r_d1           (r_d1),
-    .r_v1           (r_v1)
+        .clk            (clk),
+        .rst            (reset),
+
+        .MEM_to_WB      (MEM_to_WB),
+        .MEM_to_WB_zip  (MEM_to_WB_zip),
+        .MEM_except_zip (MEM_except_zip),
+        .WB_allowin     (WB_allowin),
+
+        .rf_wen         (wb_rf_wen),
+        .rf_waddr       (wb_rf_waddr),
+        .rf_wdata_final (wb_rf_wdata),
+        .inst_retire    (wb_inst_retire),
+
+        .csr_re         (csr_re),
+        .csr_num        (csr_num),
+        .csr_we         (csr_we),
+        .csr_wmask      (csr_wmask),
+        .csr_wvalue     (csr_wvalue),
+        .ertn_flush     (ertn_flush),
+        .except_tlbr    (except_tlbr),
+        .wb_pc          (wb_pc),
+        .wb_ex          (wb_ex),
+        .wb_ecode       (wb_ecode),
+        .wb_esubcode    (wb_esubcode),
+        .wb_vaddr       (wb_vaddr),
+
+        .csr_rvalue     (csr_rvalue),
+        .csr_estat_data (csr_estat_data),
+        .csr_tlbidx_data    (csr_tlbidx_data),
+        .csr_tlbehi_data    (csr_tlbehi_data),
+        .csr_tlbelo0_data   (csr_tlbelo0_data),
+        .csr_tlbelo1_data   (csr_tlbelo1_data),
+        .csr_asid_data  (csr_asid_data),
+
+        .tlb_flush      (tlb_flush),
+        .tlb_flush_target   (tlb_flush_target),
+
+        .tlbrd          (inst_tlbrd),
+        .tlbehi_wdata   (tlbehi_wdata),
+        .tlbelo0_wdata  (tlbelo0_wdata),
+        .tlbelo1_wdata  (tlbelo1_wdata),
+        .tlbidx_wdata   (tlbidx_wdata),
+        .tlbasid_wdata  (tlbasid_wdata),
+
+        .we             (tlb_we),
+        .w_index        (w_index),
+        .w_e            (w_e),
+        .w_vppn         (w_vppn),
+        .w_ps           (w_ps),
+        .w_asid         (w_asid),
+        .w_g            (w_g),
+        .w_ppn0         (w_ppn0),
+        .w_plv0         (w_plv0),
+        .w_mat0         (w_mat0),
+        .w_d0           (w_d0),
+        .w_v0           (w_v0),
+        .w_ppn1         (w_ppn1),
+        .w_plv1         (w_plv1),
+        .w_mat1         (w_mat1),
+        .w_d1           (w_d1), 
+        .w_v1           (w_v1),
+        .r_index        (r_index),
+        .r_e            (r_e),
+        .r_vppn         (r_vppn),
+        .r_ps           (r_ps),
+        .r_asid         (r_asid),
+        .r_g            (r_g),
+        .r_ppn0         (r_ppn0),
+        .r_plv0         (r_plv0),
+        .r_mat0         (r_mat0),
+        .r_d0           (r_d0),
+        .r_v0           (r_v0),
+        .r_ppn1         (r_ppn1),
+        .r_plv1         (r_plv1),
+        .r_mat1         (r_mat1),
+        .r_d1           (r_d1),
+        .r_v1           (r_v1)
 );
 
 // regfile instance
 regfile u_regfile (
-    .clk    (clk),
-    .raddr1 (rf_raddr1),
-    .rdata1 (rf_rdata1),
-    .raddr2 (rf_raddr2),
-    .rdata2 (rf_rdata2),
-    .we     (wb_rf_wen),
-    .waddr  (wb_rf_waddr),
-    .wdata  (wb_rf_wdata)
+        .clk    (clk),
+        .raddr1 (rf_raddr1),
+        .rdata1 (rf_rdata1),
+        .raddr2 (rf_raddr2),
+        .rdata2 (rf_rdata2),
+        .we     (wb_rf_wen),
+        .waddr  (wb_rf_waddr),
+        .wdata  (wb_rf_wdata)
 );
 
 // csr instance
-csr u_csr(
-    .clk        (clk),
-    .reset      (~aresetn),
-
-    .csr_re     (csr_re),
-    .csr_num    (csr_num),
-    .csr_rvalue (csr_rvalue),
-    .csr_we     (csr_we),
-    .csr_wmask  (csr_wmask),
-    .csr_wvalue (csr_wvalue),
-
-    .has_int    (has_int),
-    .ertn_flush (ertn_flush), 
-    .wb_ex      (wb_ex),
-    .wb_pc      (wb_pc),
-    .wb_vaddr   (wb_vaddr), 
-    .wb_ecode   (wb_ecode),
-    .wb_esubcode(wb_esubcode),
-    .csr_eentry_data    (csr_eentry_data),
-    .csr_tlbrentry_data (csr_tlbrentry_data),
-    .csr_era_pc (csr_era_pc),
-
-    .csr_dmw0_data      (csr_dmw0_data),
-    .csr_dmw1_data      (csr_dmw1_data),
-    .csr_asid_data      (csr_asid_data),
-    .csr_crmd_data      (csr_crmd_data),
-
-    .inst_tlbrd (inst_tlbrd),
-    .tlbehi_wdata       (tlbehi_wdata),
-    .tlbelo0_wdata      (tlbelo0_wdata),
-    .tlbelo1_wdata      (tlbelo1_wdata),
-    .tlbidx_wdata       (tlbidx_wdata),
-    .tlbasid_wdata      (tlbasid_wdata),
-
-    .csr_estat_data     (csr_estat_data),
-    .csr_tlbidx_data    (csr_tlbidx_data),
-    .csr_tlbehi_data    (csr_tlbehi_data),
-    .csr_tlbelo0_data   (csr_tlbelo0_data),
-    .csr_tlbelo1_data   (csr_tlbelo1_data)
+csr u_csr (
+        .clk        (clk),
+        .reset      (~aresetn),
+
+        .csr_re     (csr_re),
+        .csr_num    (csr_num),
+        .csr_rvalue (csr_rvalue),
+        .csr_we     (csr_we),
+        .csr_wmask  (csr_wmask),
+        .csr_wvalue (csr_wvalue),
+
+        .has_int    (has_int),
+        .ertn_flush (ertn_flush), 
+        .wb_ex      (wb_ex),
+        .wb_pc      (wb_pc),
+        .wb_vaddr   (wb_vaddr), 
+        .wb_ecode   (wb_ecode),
+        .wb_esubcode(wb_esubcode),
+        .csr_eentry_data    (csr_eentry_data),
+        .csr_tlbrentry_data (csr_tlbrentry_data),
+        .csr_era_pc (csr_era_pc),
+
+        .csr_dmw0_data      (csr_dmw0_data),
+        .csr_dmw1_data      (csr_dmw1_data),
+        .csr_asid_data      (csr_asid_data),
+        .csr_crmd_data      (csr_crmd_data),
+
+        .inst_tlbrd (inst_tlbrd),
+        .tlbehi_wdata       (tlbehi_wdata),
+        .tlbelo0_wdata      (tlbelo0_wdata),
+        .tlbelo1_wdata      (tlbelo1_wdata),
+        .tlbidx_wdata       (tlbidx_wdata),
+        .tlbasid_wdata      (tlbasid_wdata),
+
+        .csr_estat_data     (csr_estat_data),
+        .csr_tlbidx_data    (csr_tlbidx_data),
+        .csr_tlbehi_data    (csr_tlbehi_data),
+        .csr_tlbelo0_data   (csr_tlbelo0_data),
+        .csr_tlbelo1_data   (csr_tlbelo1_data)
 );
 
-assign flush = ertn_flush | wb_ex | tlb_flush;
-assign flush_target = ertn_flush? csr_era_pc : 
-                      wb_ex?      {32{except_tlbr}} & csr_tlbrentry_data | {32{~except_tlbr}} & csr_eentry_data : 
-                                  tlb_flush_target ;
-
-// tie-off instruction sram write controls (read-only from CPU)
-assign inst_sram_wstrb = 4'b0;
-assign inst_sram_wdata = 32'b0;
-assign inst_sram_wr    = | inst_sram_wstrb;
-assign inst_sram_size  = 2'b10;
-assign data_sram_wr    = | data_sram_wstrb;
-
 // inst mmu instance
-mmu u_inst_mmu(
-    .mem_we         (1'b0),
-    .mmu_en         (1'b1),
-    .vaddr          (pc_next),
-    .paddr          (pc_trans),
-    .s_vppn         (s0_vppn),
-    .s_va_bit12     (s0_va_bit12),
-    .s_asid         (s0_asid),
-    .s_found        (s0_found),
-    .s_index        (s0_index),
-    .s_ppn          (s0_ppn),
-    .s_ps           (s0_ps),     
-    .s_plv          (s0_plv),
-    .s_mat          (s0_mat),
-    .s_d            (s0_d),
-    .s_v            (s0_v),
-
-    .csr_asid_data  (csr_asid_data),
-    .csr_crmd_data  (csr_crmd_data),
-    .csr_dmw0_data  (csr_dmw0_data),
-    .csr_dmw1_data  (csr_dmw1_data),
-
-    .except_tlbr    (except_tlbr_if),
-    .except_pif     (except_pif),
-    .except_pil     (),
-    .except_pis     (),
-    .except_pme     (),
-    .except_ppi     (except_ppi_if)
+mmu u_inst_mmu (
+        .mem_we         (1'b0),
+        .mmu_en         (1'b1),
+        .is_if          (1'b1),
+        .vaddr          (pc_next),
+        .paddr          (pc_trans),
+        .cacheable      (pc_cacheable),
+        .s_vppn         (s0_vppn),
+        .s_va_bit12     (s0_va_bit12),
+        .s_asid         (s0_asid),
+        .s_found        (s0_found),
+        .s_index        (s0_index),
+        .s_ppn          (s0_ppn),
+        .s_ps           (s0_ps),     
+        .s_plv          (s0_plv),
+        .s_mat          (s0_mat),
+        .s_d            (s0_d),
+        .s_v            (s0_v),
+
+        .csr_asid_data  (csr_asid_data),
+        .csr_crmd_data  (csr_crmd_data),
+        .csr_dmw0_data  (csr_dmw0_data),
+        .csr_dmw1_data  (csr_dmw1_data),
+
+        .except_tlbr    (except_tlbr_if),
+        .except_pif     (except_pif),
+        .except_pil     (),
+        .except_pis     (),
+        .except_pme     (),
+        .except_ppi     (except_ppi_if)
 );
 
 // data mmu instance
-mmu u_data_mmu(
-    .mem_we         (mem_we),
-    .mmu_en         (mmu_en),
-    .vaddr          (ex_vaddr),
-    .paddr          (addr_trans),
-    .s_vppn         (s1_vppn),
-    .s_va_bit12     (s1_va_bit12),
-    .s_asid         (),
-    .s_found        (s1_found),
-    .s_index        (s1_index),
-    .s_ppn          (s1_ppn),
-    .s_ps           (s1_ps),     
-    .s_plv          (s1_plv),
-    .s_mat          (s1_mat),
-    .s_d            (s1_d),
-    .s_v            (s1_v),
-
-    .csr_asid_data  (csr_asid_data),
-    .csr_crmd_data  (csr_crmd_data),
-    .csr_dmw0_data  (csr_dmw0_data),
-    .csr_dmw1_data  (csr_dmw1_data),
-
-    .except_tlbr    (except_tlbr_mem),
-    .except_pif     (),
-    .except_pil     (except_pil),
-    .except_pis     (except_pis),
-    .except_pme     (except_pme),
-    .except_ppi     (except_ppi_mem)
+mmu u_data_mmu (
+        .mem_we         (mem_we),
+        .mmu_en         (mmu_en),
+        .is_if          (1'b0),
+        .vaddr          (ex_vaddr),
+        .paddr          (addr_trans),
+        .cacheable      (addr_cacheable),
+        .s_vppn         (s1_vppn),
+        .s_va_bit12     (s1_va_bit12),
+        .s_asid         (),
+        .s_found        (s1_found),
+        .s_index        (s1_index),
+        .s_ppn          (s1_ppn),
+        .s_ps           (s1_ps),     
+        .s_plv          (s1_plv),
+        .s_mat          (s1_mat),
+        .s_d            (s1_d),
+        .s_v            (s1_v),
+
+        .csr_asid_data  (csr_asid_data),
+        .csr_crmd_data  (csr_crmd_data),
+        .csr_dmw0_data  (csr_dmw0_data),
+        .csr_dmw1_data  (csr_dmw1_data),
+
+        .except_tlbr    (except_tlbr_mem),
+        .except_pif     (),
+        .except_pil     (except_pil),
+        .except_pis     (except_pis),
+        .except_pme     (except_pme),
+        .except_ppi     (except_ppi_mem)
 );
 
-
 // tlb instance
-tlb u_tlb(
-    .clk            (clk),
-    .s0_vppn        (s0_vppn),
-    .s0_va_bit12    (s0_va_bit12),
-    .s0_asid        (s0_asid),
-    .s0_found       (s0_found),
-    .s0_index       (s0_index),
-    .s0_ppn         (s0_ppn),
-    .s0_ps          (s0_ps),     
-    .s0_plv         (s0_plv),
-    .s0_mat         (s0_mat),
-    .s0_d           (s0_d),
-    .s0_v           (s0_v),
-
-    .s1_vppn        (s1_vppn),
-    .s1_va_bit12    (s1_va_bit12),
-    .s1_asid        (s1_asid),
-    .s1_found       (s1_found),
-    .s1_index       (s1_index),
-    .s1_ppn         (s1_ppn),
-    .s1_ps          (s1_ps),     
-    .s1_plv         (s1_plv),
-    .s1_mat         (s1_mat),
-    .s1_d           (s1_d),
-    .s1_v           (s1_v),
-
-    .invtlb_valid   (invtlb_valid),    
-    .invtlb_op      (invtlb_op),
-    .we             (tlb_we),
-    .w_index        (w_index),
-    .w_e            (w_e),
-    .w_vppn         (w_vppn),
-    .w_ps           (w_ps),
-    .w_asid         (w_asid),
-    .w_g            (w_g),
-    .w_ppn0         (w_ppn0),
-    .w_plv0         (w_plv0),
-    .w_mat0         (w_mat0),
-    .w_d0           (w_d0),
-    .w_v0           (w_v0),
-    .w_ppn1         (w_ppn1),
-    .w_plv1         (w_plv1),
-    .w_mat1         (w_mat1),
-    .w_d1           (w_d1), 
-    .w_v1           (w_v1),
-    .r_index        (r_index),
-    .r_e            (r_e),
-    .r_vppn         (r_vppn),
-    .r_ps           (r_ps),
-    .r_asid         (r_asid),
-    .r_g            (r_g),
-    .r_ppn0         (r_ppn0),
-    .r_plv0         (r_plv0),
-    .r_mat0         (r_mat0),
-    .r_d0           (r_d0),
-    .r_v0           (r_v0),
-    .r_ppn1         (r_ppn1),
-    .r_plv1         (r_plv1),
-    .r_mat1         (r_mat1),
-    .r_d1           (r_d1),
-    .r_v1           (r_v1)   
+tlb u_tlb (
+        .clk            (clk),
+        .s0_vppn        (s0_vppn),
+        .s0_va_bit12    (s0_va_bit12),
+        .s0_asid        (s0_asid),
+        .s0_found       (s0_found),
+        .s0_index       (s0_index),
+        .s0_ppn         (s0_ppn),
+        .s0_ps          (s0_ps),     
+        .s0_plv         (s0_plv),
+        .s0_mat         (s0_mat),
+        .s0_d           (s0_d),
+        .s0_v           (s0_v),
+
+        .s1_vppn        (s1_vppn),
+        .s1_va_bit12    (s1_va_bit12),
+        .s1_asid        (s1_asid),
+        .s1_found       (s1_found),
+        .s1_index       (s1_index),
+        .s1_ppn         (s1_ppn),
+        .s1_ps          (s1_ps),     
+        .s1_plv         (s1_plv),
+        .s1_mat         (s1_mat),
+        .s1_d           (s1_d),
+        .s1_v           (s1_v),
+
+        .invtlb_valid   (invtlb_valid),    
+        .invtlb_op      (invtlb_op),
+        .we             (tlb_we),
+        .w_index        (w_index),
+        .w_e            (w_e),
+        .w_vppn         (w_vppn),
+        .w_ps           (w_ps),
+        .w_asid         (w_asid),
+        .w_g            (w_g),
+        .w_ppn0         (w_ppn0),
+        .w_plv0         (w_plv0),
+        .w_mat0         (w_mat0),
+        .w_d0           (w_d0),
+        .w_v0           (w_v0),
+        .w_ppn1         (w_ppn1),
+        .w_plv1         (w_plv1),
+        .w_mat1         (w_mat1),
+        .w_d1           (w_d1), 
+        .w_v1           (w_v1),
+        .r_index        (r_index),
+        .r_e            (r_e),
+        .r_vppn         (r_vppn),
+        .r_ps           (r_ps),
+        .r_asid         (r_asid),
+        .r_g            (r_g),
+        .r_ppn0         (r_ppn0),
+        .r_plv0         (r_plv0),
+        .r_mat0         (r_mat0),
+        .r_d0           (r_d0),
+        .r_v0           (r_v0),
+        .r_ppn1         (r_ppn1),
+        .r_plv1         (r_plv1),
+        .r_mat1         (r_mat1),
+        .r_d1           (r_d1),
+        .r_v1           (r_v1)   
 );
 
-// inst_retire_reg format: { pc(32), {4{rf_wen}}(4), rf_waddr(5), rf_wdata(32) }
-assign {
-        debug_wb_pc,
-        debug_wb_rf_we,
-        debug_wb_rf_wnum,
-        debug_wb_rf_wdata
-} = wb_inst_retire;
+// I-Cache instance
+cache u_I_Cache (
+        .clk    (clk),
+        .resetn (~reset),
+        .valid  (icache_valid),
+        .op     (icache_op),
+        .cacheable      (icache_cacheable),
+        .index  (icache_index),
+        .tag    (icache_tag),
+        .offset (icache_offset),
+        .wstrb  (4'b0),
+        .wdata  (32'b0),
+        .addr_ok        (icache_addr_ok),
+        .data_ok        (icache_data_ok),
+        .rdata  (icache_rdata),
+        .rd_req (icache_rd_req),
+        .rd_type        (icache_rd_type),
+        .rd_addr        (icache_rd_addr),
+        .rd_rdy (icache_rd_rdy),
+        .ret_valid      (icache_ret_valid),
+        .ret_last       (icache_ret_last),
+        .ret_data       (icache_ret_data),
+        .wr_req (),
+        .wr_type        (),
+        .wr_addr        (),
+        .wr_wstrb       (),
+        .wr_data        (),
+        .wr_rdy (1'b0)
+);
+
+// D-Cache instance
+cache u_D_Cache (
+        .clk    (clk),
+        .resetn (~reset),
+        .valid  (dcache_valid),
+        .op     (dcache_op),
+        .cacheable      (dcache_cacheable),
+        .index  (dcache_index),
+        .tag    (dcache_tag),
+        .offset (dcache_offset),
+        .wstrb  (dcache_wstrb),
+        .wdata  (dcache_wdata),
+        .addr_ok        (dcache_addr_ok),
+        .data_ok        (dcache_data_ok),
+        .rdata  (dcache_rdata),
+        .rd_req (dcache_rd_req),
+        .rd_type        (dcache_rd_type),
+        .rd_addr        (dcache_rd_addr),
+        .rd_rdy (dcache_rd_rdy),
+        .ret_valid      (dcache_ret_valid),
+        .ret_last       (dcache_ret_last),
+        .ret_data       (dcache_ret_data),
+        .wr_req (dcache_wr_req),
+        .wr_type        (dcache_wr_type),
+        .wr_addr        (dcache_wr_addr),
+        .wr_wstrb       (dcache_wr_wstrb),
+        .wr_data        (dcache_wr_data),
+        .wr_rdy (dcache_wr_rdy)
+);
 
 endmodule
\ No newline at end of file
-- 
2.51.0

